{
  "begin": {
    "params": [],
    "body": "{\n  return {\n    commit: dummy_1,\n    rollback: dummy_1\n  };\n}",
    "snippets": [],
    "comments": []
  },
  "any": {
    "params": [
      "promises"
    ],
    "body": "{\n  var ret = new SomePromiseArray(promises);\n  var promise = ret.promise();\n  ASSERT(promise.isPending());\n  ASSERT(ret instanceof SomePromiseArray);\n  ret.setHowMany(1);\n  ret.setUnwrap();\n  ret.init();\n  return promise;\n}",
    "snippets": [
      "Promise.any(Iterable<any>|Promise<Iterable<any>> input) -> Promise\n"
    ],
    "comments": []
  },
  "Async": {
    "params": [],
    "body": "{\n  this._isTickUsed = false;\n  this._length = 0;\n  this._backupBuffer = [];\n  var functionBuffer = this._functionBuffer = new Array(1000 * 3);\n  var self = this;\n  this.consumeFunctionBuffer = function Async$consumeFunctionBuffer() {\n    self._consumeFunctionBuffer();\n  };\n  for (var i = 0, len = functionBuffer.length; i < len; ++i) {\n    functionBuffer[i] = void 0;\n  }\n}",
    "snippets": [
      "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <title>Async Dislogs Example</title>\n  <script src=\"//cdn.jsdelivr.net/bluebird/{{ site.version }}/bluebird.js\"></script>\n  <script type=\"text/javascript\">\n    document.addEventListener('DOMContentLoaded', function() {\n      var time = document.getElementById('time-stamp');\n      clockTick();\n      setInterval(clockTick, 1000);\n      function clockTick() {\n        time.innerHTML = new Date().toLocaleTimeString();\n      }\n    });\n  </script>\n</head>\n<body>\n  <p>The current time is <span id=\"time-stamp\"></span>.</p>\n  <p>Your name is <span id=\"prompt\"></span>.</p>\n  <button id=\"action\">Set Name</button>\n</body>\n</html>\n",
      "function promptPromise(message) {\n  return new Promise(function(resolve, reject) {\n    var result = window.prompt(message);\n    if (result != null) {\n      resolve(result);\n    } else {\n      reject(new Error('User cancelled'));\n    }\n  });\n}\n\nvar button = document.getElementById('action');\nvar output = document.getElementById('prompt');\n\nbutton.addEventListener('click', function() {\n  promptPromise('What is your name?')\n    .then(function(name) {\n      output.innerHTML = String(name);\n    })\n    .catch(function() {\n      output.innerHTML = '¯\\\\_(ツ)_/¯';\n    });\n});\n",
      "<style type=\"text/css\">\n  #dialog {\n    width:      200px;\n    margin:     auto;\n    padding:    10px;\n    border:     thin solid black;\n    background: lightgreen;\n  }\n  .hidden {\n    display: none;\n  }\n</style>\n<div id=\"dialog\" class=\"hidden\">\n  <div class=\"message\">foobar</div>\n  <input type=\"text\">\n  <div>\n    <button class=\"ok\">Ok</button>\n    <button class=\"cancel\">Cancel</button>\n  </div>\n</div>\n",
      "function promptPromise(message) {\n  var dialog       = document.getElementById('dialog');\n  var input        = dialog.querySelector('input');\n  var okButton     = dialog.querySelector('button.ok');\n  var cancelButton = dialog.querySelector('button.cancel');\n\n  dialog.querySelector('.message').innerHTML = String(message);\n  dialog.className = '';\n\n  return new Promise(function(resolve, reject) {\n    dialog.addEventListener('click', function handleButtonClicks(e) {\n      if (e.target.tagName !== 'BUTTON') { return; }\n      dialog.removeEventListener('click', handleButtonClicks);\n      dialog.className = 'hidden';\n      if (e.target === okButton) {\n        resolve(input.value);\n      } else {\n        reject(new Error('User cancelled'));\n      }\n    });\n  });\n}\n",
      "return new Promise(function(resolve, reject) {\n  $('#okButton').on('click.promptDialog', function() {\n    resolve(input.value);\n  });\n  $('#cancelButton').on('click.promptDialog', reject);\n})\n.finally(function() {\n  $('#okButton').off('click.promptDialog');\n  $('#cancelButton').off('click.promptDialog');\n});\n",
      "var noop = function() {\n  return this;\n};\n\nfunction Dialog() {\n  this.setCallbacks(noop, noop);\n}\nDialog.prototype.setCallbacks = function(okCallback, cancelCallback) {\n  this._okCallback     = okCallback;\n  this._cancelCallback = cancelCallback;\n  return this;\n};\nDialog.prototype.waitForUser = function() {\n  var _this = this;\n  return new Promise(function(resolve, reject) {\n    _this.setCallbacks(resolve, reject);\n  });\n};\nDialog.prototype.show = noop;\nDialog.prototype.hide = noop;\n",
      "function PromptDialog() {\n  Dialog.call(this);\n  this.el           = document.getElementById('dialog');\n  this.inputEl      = this.el.querySelector('input');\n  this.messageEl    = this.el.querySelector('.message');\n  this.okButton     = this.el.querySelector('button.ok');\n  this.cancelButton = this.el.querySelector('button.cancel');\n  this.attachDomEvents();\n}\nPromptDialog.prototype = Object.create(Dialog.prototype);\nPromptDialog.prototype.attachDomEvents = function() {\n  var _this = this;\n  this.okButton.addEventListener('click', function() {\n    _this._okCallback(_this.inputEl.value);\n  });\n  this.cancelButton.addEventListener('click', function() {\n    _this._cancelCallback();\n  });\n};\nPromptDialog.prototype.show = function(message) {\n  this.messageEl.innerHTML = String(message);\n  this.el.className = '';\n  return this;\n};\nPromptDialog.prototype.hide = function() {\n  this.el.className = 'hidden';\n  return this;\n};\n",
      "var output = document.getElementById('prompt');\nvar prompt = new PromptDialog();\n\nprompt.show('What is your name?')\n  .waitForUser()\n  .then(function(name) {\n    output.innerHTML = String(name);\n  })\n  .catch(function() {\n    output.innerHTML = '¯\\\\_(ツ)_/¯';\n  })\n  .finally(function() {\n    prompt.hide();\n  });\n",
      "function NotifyDialog() {\n  Dialog.call(this);\n  var _this      = this;\n  this.el        = document.getElementById('notify-dialog');\n  this.messageEl = this.el.querySelector('.message');\n  this.okButton  = this.el.querySelector('button.ok');\n  this.okButton.addEventListener('click', function() {\n    _this._okCallback();\n  });\n}\nNotifyDialog.prototype = Object.create(Dialog.prototype);\nNotifyDialog.prototype.show = function(message) {\n  this.messageEl.innerHTML = String(message);\n  this.el.className = '';\n  return this;\n};\nNotifyDialog.prototype.show = function() {\n  this.el.className = 'hidden';\n  return this;\n};\n"
    ],
    "comments": []
  },
  "noConflict": {
    "params": [],
    "body": "{\n  try {\n    if (Promise === bluebird) Promise = old;\n  } catch (e) {}\n  return bluebird;\n}",
    "snippets": [
      "Promise.noConflict() -> Object\n",
      "<!-- the other promise library must be loaded first -->\n<script type=\"text/javascript\" src=\"/scripts/other_promise.js\"></script>\n<script type=\"text/javascript\" src=\"/scripts/bluebird_debug.js\"></script>\n<script type=\"text/javascript\">\n//Release control right after\nvar Bluebird = Promise.noConflict();\n\n//Cast a promise from some other Promise library using the Promise namespace to Bluebird:\nvar promise = Bluebird.resolve(new Promise());\n</script>\n"
    ],
    "comments": []
  },
  "deprecated": {
    "params": [
      "name",
      "replacement"
    ],
    "body": "{\n  var message = name + \" is deprecated and will be removed in a future version.\";\n  if (replacement) message += \" Use \" + replacement + \" instead.\";\n  return warn(message);\n}",
    "snippets": [
      "function delay(ms) {\n    var resolver = Promise.defer();\n    var now = Date.now();\n    setTimeout(function() {\n        resolver.resolve(Date.now() - now);\n    }, ms);\n    return resolver.promise;\n}\n\ndelay(500).then(function(ms) {\n    console.log(ms + \" ms passed\");\n});\n"
    ],
    "comments": []
  },
  "warn": {
    "params": [
      "message",
      "shouldUseOwnTrace",
      "promise"
    ],
    "body": "{\n  if (!config.warnings) return;\n  var warning = new Warning(message);\n  var ctx;\n  if (shouldUseOwnTrace) {\n    promise._attachExtraTrace(warning);\n  } else if (config.longStackTraces && (ctx = Promise._peekContext())) {\n    ctx.attachExtraTrace(warning);\n  } else {\n    var parsed = parseStackAndMessage(warning);\n    warning.stack = parsed.message + \"\\n\" + parsed.stack.join(\"\\n\");\n  }\n  if (!activeFireEvent(\"warning\", warning)) {\n    formatAndLogError(warning, \"\", true);\n  }\n}",
    "snippets": [],
    "comments": []
  },
  "OperationalError": {
    "params": [
      "message"
    ],
    "body": "{\n  if (!(this instanceof OperationalError)) return new OperationalError(message);\n  notEnumerableProp(this, \"name\", \"OperationalError\");\n  notEnumerableProp(this, \"message\", message);\n  this.cause = message;\n  this[OPERATIONAL_ERROR_KEY] = true;\n  if (message instanceof Error) {\n    notEnumerableProp(this, \"message\", message.message);\n    notEnumerableProp(this, \"stack\", message.stack);\n  } else if (Error.captureStackTrace) {\n    Error.captureStackTrace(this, this.constructor);\n  }\n}",
    "snippets": [
      "new OperationalError(String message) -> OperationalError\n"
    ],
    "comments": []
  },
  "map": {
    "params": [
      "cov"
    ],
    "body": "{\n  var ret = {\n    instrumentation: 'node-jscoverage',\n    sloc: 0,\n    hits: 0,\n    misses: 0,\n    coverage: 0,\n    files: []\n  };\n  for (var filename in cov) {\n    var data = coverage(filename, cov[filename]);\n    ret.files.push(data);\n    ret.hits += data.hits;\n    ret.misses += data.misses;\n    ret.sloc += data.sloc;\n  }\n  ret.files.sort(function (a, b) {\n    return a.filename.localeCompare(b.filename);\n  });\n  if (ret.sloc > 0) {\n    ret.coverage = ret.hits / ret.sloc * 100;\n  }\n  return ret;\n}",
    "snippets": [
      "Promise.mapSeries(\n    Iterable<any>|Promise<Iterable<any>> input,\n    function(any value, int index, int arrayLength) mapper\n) -> Promise<Array<any>>\n",
      "// The array to be mapped over can be a mix of values and promises.\nvar fileNames = [\"1.txt\", Promise.resolve(\"2.txt\"), \"3.txt\", Promise.delay(3000, \"4.txt\"), \"5.txt\"];\n\nPromise.mapSeries(fileNames, function(fileName, index, arrayLength) {\n    // The iteration will be performed sequentially, awaiting for any\n    // promises in the process.\n    return fs.readFileAsync(fileName).then(function(fileContents) {\n        // ...\n        return fileName + \"!\";\n    });\n}).then(function(result) {\n    // This will run after the last step is done\n    console.log(\"Done!\")\n    console.log(result); // [\"1.txt!\", \"2.txt!\", \"3.txt!\", \"4.txt!\", \"5.txt!\"]\n});\n",
      "// If one of the promises in the original array rejects,\n// the iteration will stop once it reaches it\nvar items = [\"A\", Promise.delay(8000, \"B\"), Promise.reject(\"C\"), \"D\"];\n\nPromise.each(items, function(item) {\n    return Promise.delay(4000).then(function() {\n        console.log(\"On mapper: \" + item);\n    });\n}).then(function(result) {\n    // This not run\n}).catch(function(rejection) {\n    console.log(\"Catch: \" + rejection);\n});\n\n// The code above outputs the following after 12 seconds (not 16!):\n// On mapper: A\n// On mapper: B\n// Catch: C\n"
    ],
    "comments": []
  },
  "Promise": {
    "params": [
      "resolver"
    ],
    "body": "{\n  if (typeof resolver === \"function\") this._resolveResolver(resolver);\n  this._bitField = 67108864;\n  this._fulfill0 = void 0;\n  this._reject0 = void 0;\n  this._progress0 = void 0;\n  this._promise0 = void 0;\n  this._receiver0 = void 0;\n  this._resolvedValue = void 0;\n  this._cancellationParent = void 0;\n  if (longStackTraces) this._traceParent = this._peekContext();\n}",
    "snippets": [
      "fs.readFile(\"file.json\", function (err, val) {\n    if (err) {\n        console.error(\"unable to read file\");\n    }\n    else {\n        try {\n            val = JSON.parse(val);\n            console.log(val.success);\n        }\n        catch (e) {\n            console.error(\"invalid json in file\");\n        }\n    }\n});\n",
      "fs.readFileAsync(\"file.json\").then(JSON.parse).then(function (val) {\n    console.log(val.success);\n})\n.catch(SyntaxError, function (e) {\n    console.error(\"invalid json in file\");\n})\n.catch(function (e) {\n    console.error(\"unable to read file\");\n});\n",
      "try {\n    var val = JSON.parse(fs.readFileSync(\"file.json\"));\n    console.log(val.success);\n}\n// Gecko-only syntax; used for illustrative purposes\ncatch (e if e instanceof SyntaxError) {\n    console.error(\"invalid json in file\");\n}\ncatch (e) {\n    console.error(\"unable to read file\");\n}\n",
      "//Copyright Plato http://stackoverflow.com/a/19385911/995876\n//CC BY-SA 2.5\nmapSeries(URLs, function (URL, done) {\n    var options = {};\n    needle.get(URL, options, function (error, response, body) {\n        if (error) {\n            return done(error);\n        }\n        try {\n            var ret = JSON.parse(body);\n            return done(null, ret);\n        }\n        catch (e) {\n            done(e);\n        }\n    });\n}, function (err, results) {\n    if (err) {\n        console.log(err);\n    } else {\n        console.log('All Needle requests successful');\n        // results is a 1 to 1 mapping in order of URLs > needle.body\n        processAndSaveAllInDB(results, function (err) {\n            if (err) {\n                return done(err);\n            }\n            console.log('All Needle requests saved');\n            done(null);\n        });\n    }\n});\n",
      "Promise.promisifyAll(needle);\nvar options = {};\n\nvar current = Promise.resolve();\nPromise.map(URLs, function (URL) {\n    current = current.then(function () {\n        return needle.getAsync(URL, options);\n    });\n    return current;\n}).map(function (responseAndBody) {\n    return JSON.parse(responseAndBody[1]);\n}).then(function (results) {\n    return processAndSaveAllInDB(results);\n}).then(function () {\n    console.log('All Needle requests saved');\n}).catch(function (e) {\n    console.log(e);\n});\n"
    ],
    "comments": []
  },
  "promisifyAll": {
    "params": [
      "obj",
      "suffix",
      "filter",
      "promisifier",
      "multiArgs"
    ],
    "body": "{\n  ASSERT(typeof suffix === \"string\");\n  ASSERT(typeof filter === \"function\");\n  var suffixRegexp = new RegExp(escapeIdentRegex(suffix) + \"$\");\n  var methods = promisifiableMethods(obj, suffix, suffixRegexp, filter);\n  for (var i = 0, len = methods.length; i < len; i += 2) {\n    var key = methods[i];\n    var fn = methods[i + 1];\n    var promisifiedKey = key + suffix;\n    if (promisifier === makeNodePromisified) {\n      obj[promisifiedKey] = makeNodePromisified(key, THIS, key, fn, suffix, multiArgs);\n    } else {\n      var promisified = promisifier(fn, function () {\n        return makeNodePromisified(key, THIS, key, fn, suffix, multiArgs);\n      });\n      util.notEnumerableProp(promisified, \"__isPromisified__\", true);\n      obj[promisifiedKey] = promisified;\n    }\n  }\n  util.toFastProperties(obj);\n  return obj;\n}",
    "snippets": [
      "Promise.promisifyAll(\n    Object target,\n    [Object {\n        suffix: String=\"Async\",\n        multiArgs: boolean=false,\n        filter: boolean function(String name, function func, Object target, boolean passesDefaultFilter),\n        promisifier: function(function originalFunction, function defaultPromisifier)\n    } options]\n) -> Object\n",
      "Promise.promisifyAll(require(\"redis\"));\n\n//Later on, all redis client instances have promise returning functions:\n\nredisClient.hexistsAsync(\"myhash\", \"field\").then(function(v) {\n\n}).catch(function(e) {\n\n});\n",
      "var fs = Promise.promisifyAll(require(\"fs\"));\n\nfs.readFileAsync(\"myfile.js\", \"utf8\").then(function(contents) {\n    console.log(contents);\n}).catch(function(e) {\n    console.error(e.stack);\n});\n",
      "var fs = Promise.promisifyAll(require(\"fs\"), {suffix: \"MySuffix\"});\nfs.readFileMySuffix(...).then(...);\n",
      "module.exports = function myPromisifyAll(target) {\n    return Promise.promisifyAll(target, {suffix: \"MySuffix\"});\n};\n",
      "Promise.promisifyAll(something, {\n    filter: function(name) {\n        return name === \"theMultiArgMethodIwant\";\n    },\n    multiArgs: true\n});\n// Rest of the methods\nPromise.promisifyAll(something);\n",
      "Promise.promisifyAll(..., {\n    filter: function(name, func, target, passesDefaultFilter) {\n        // name = the property name to be promisified without suffix\n        // func = the function\n        // target = the target object where the promisified func will be put with name + suffix\n        // passesDefaultFilter = whether the default filter would be passed\n        // return boolean (return value is coerced, so not returning anything is same as returning false)\n\n        return passesDefaultFilter && ...\n    }\n})\n",
      "function DOMPromisifier(originalMethod) {\n    // return a function\n    return function promisified() {\n        var args = [].slice.call(arguments);\n        // Needed so that the original method can be called with the correct receiver\n        var self = this;\n        // which returns a promise\n        return new Promise(function(resolve, reject) {\n            args.push(resolve, reject);\n            originalMethod.apply(self, args);\n        });\n    };\n}\n\n// Promisify e.g. chrome.browserAction\nPromise.promisifyAll(chrome.browserAction, {promisifier: DOMPromisifier});\n\n// Later\nchrome.browserAction.getTitleAsync({tabId: 1})\n    .then(function(result) {\n\n    });\n",
      "var Promise = require(\"bluebird\");\nvar restler = require(\"restler\");\nvar methodNamesToPromisify = \"get post put del head patch json postJson putJson\".split(\" \");\n\nfunction EventEmitterPromisifier(originalMethod) {\n    // return a function\n    return function promisified() {\n        var args = [].slice.call(arguments);\n        // Needed so that the original method can be called with the correct receiver\n        var self = this;\n        // which returns a promise\n        return new Promise(function(resolve, reject) {\n            // We call the originalMethod here because if it throws,\n            // it will reject the returned promise with the thrown error\n            var emitter = originalMethod.apply(self, args);\n\n            emitter\n                .on(\"success\", function(data, response) {\n                    resolve([data, response]);\n                })\n                .on(\"fail\", function(data, response) {\n                    // Erroneous response like 400\n                    resolve([data, response]);\n                })\n                .on(\"error\", function(err) {\n                    reject(err);\n                })\n                .on(\"abort\", function() {\n                    reject(new Promise.CancellationError());\n                })\n                .on(\"timeout\", function() {\n                    reject(new Promise.TimeoutError());\n                });\n        });\n    };\n};\n\nPromise.promisifyAll(restler, {\n    filter: function(name) {\n        return methodNamesToPromisify.indexOf(name) > -1;\n    },\n    promisifier: EventEmitterPromisifier\n});\n\n// ...\n\n// Later in some other file\n\nvar restler = require(\"restler\");\nrestler.getAsync(\"http://...\", ...,).spread(function(data, response) {\n\n})\n",
      "var fs = Promise.promisifyAll(require(\"fs\"), {\n    promisifier: function(originalFunction, defaultPromisifer) {\n        var promisified = defaultPromisifier(originalFunction);\n\n        return function() {\n            // Enhance normal promisification by supporting promises as\n            // arguments\n\n            var args = [].slice.call(arguments);\n            var self = this;\n            return Promise.all(args).then(function(awaitedArgs) {\n                return promisified.apply(self, awaitedArgs);\n            });\n        };\n    }\n});\n\n// All promisified fs functions now await their arguments if they are promises\nvar version = fs.readFileAsync(\"package.json\", \"utf8\").then(JSON.parse).get(\"version\");\nfs.writeFileAsync(\"the-version.txt\", version, \"utf8\");\n",
      "var Pool = require(\"mysql/lib/Pool\");\nvar Connection = require(\"mysql/lib/Connection\");\nPromise.promisifyAll([Pool, Connection]);\n"
    ],
    "comments": []
  },
  "promisify": {
    "params": [
      "callback",
      "receiver",
      "multiArgs"
    ],
    "body": "{\n  return makeNodePromisified(callback, receiver, undefined, callback, null, multiArgs);\n}",
    "snippets": [
      "var fs = Promise.promisify(require(\"fs\"));\n",
      "var fs = Promise.promisifyAll(require(\"fs\"));\n",
      "function wrapWithPromise(parameter) {\n    return new Promise(function (resolve, reject) {\n        doSomethingAsync({\n              error:reject,\n              success:resolve\n        });\n    });\n}\n",
      "function returnThree(){ return 3;}\n\nPromise.resolve(5).map(returnThree).then(function(val){\n     console.log(\"Hello Value!\",val); \n});\n",
      "function returnThree(){ return 3;}\n\nPromise.resolve([5]).map(returnThree).then(function(val){\n     console.log(\"Hello Value!\",val); \n});\n",
      "function nextFunction(something){ return Promise.resolve(something*3); }\n\nmyFunction()\n    .then(result => nextFunction(result)); // We are implicitly returning a Promise\n",
      "function nextFunction(something){ return Promise.resolve(something*3); }\n\nmyFunction().then(result => {\n    console.log(\"Debug:\", result);\n    nextFunction(result)); // The chain is broken! We don't return anything to the .then() call\n});\n",
      "function nextFunction(something){ return Promise.resolve(something*3); }\n\nmyFunction().then(result => {\n    console.log(\"Debug:\", result);\n    return nextFunction(result)); // The anonymous function returns the function which returns the promise .then() needs\n});\n"
    ],
    "comments": [
      "Error: the promise constructor requires a resolver function",
      "Error: the promise constructor cannot be invoked directly",
      "Error: expecting an array, a promise or a thenable"
    ]
  },
  "props": {
    "params": [
      "promises"
    ],
    "body": "{\n  var ret;\n  var castValue = tryConvertToPromise(promises);\n  if (!isObject(castValue)) {\n    return apiRejection(PROPS_TYPE_ERROR);\n  } else if (castValue instanceof Promise) {\n    ret = castValue._then(Promise.props, undefined, undefined, undefined, undefined);\n  } else {\n    ret = new PropertiesPromiseArray(castValue).promise();\n  }\n  if (castValue instanceof Promise) {\n    ret._propagateFrom(castValue, PROPAGATE_BIND);\n  }\n  return ret;\n}",
    "snippets": [
      ".props() -> Promise\n"
    ],
    "comments": []
  },
  "race": {
    "params": [
      "promises",
      "parent"
    ],
    "body": "{\n  var maybePromise = tryConvertToPromise(promises);\n  if (maybePromise instanceof Promise) {\n    return raceLater(maybePromise);\n  } else {\n    promises = util.asArray(promises);\n    if (promises === null) return apiRejection(COLLECTION_ERROR + util.classString(promises));\n  }\n  var ret = new Promise(INTERNAL);\n  if (parent !== undefined) {\n    ret._propagateFrom(parent, PROPAGATE_ALL);\n  }\n  var fulfill = ret._fulfill;\n  var reject = ret._reject;\n  for (var i = 0, len = promises.length; i < len; ++i) {\n    var val = promises[i];\n    if (val === undefined && !((i in promises))) {\n      continue;\n    }\n    Promise.cast(val)._then(fulfill, reject, undefined, ret, null);\n  }\n  return ret;\n}",
    "snippets": [
      ".race() -> Promise\n"
    ],
    "comments": []
  },
  "reduce": {
    "params": [
      "fun"
    ],
    "body": "{\n  var object = toObject(this), self = splitString && _toString(this) == \"[object String]\" ? this.split(\"\") : object, length = self.length >>> 0;\n  if (_toString(fun) != \"[object Function]\") {\n    throw new TypeError(fun + \" is not a function\");\n  }\n  if (!length && arguments.length == 1) {\n    throw new TypeError(\"reduce of empty array with no initial value\");\n  }\n  var i = 0;\n  var result;\n  if (arguments.length >= 2) {\n    result = arguments[1];\n  } else {\n    do {\n      if ((i in self)) {\n        result = self[i++];\n        break;\n      }\n      if (++i >= length) {\n        throw new TypeError(\"reduce of empty array with no initial value\");\n      }\n    } while (true);\n  }\n  for (; i < length; i++) {\n    if ((i in self)) {\n      result = fun.call(void 0, result, self[i], i, object);\n    }\n  }\n  return result;\n}",
    "snippets": [
      ".reduce(\n    function(any accumulator, any item, int index, int length) reducer,\n    [any initialValue]\n) -> Promise\n"
    ],
    "comments": []
  },
  "schedule": {
    "params": [
      "task",
      "queued"
    ],
    "body": "{\n  var worker = workers.filter(function (worker) {\n    return task.isolated ? !worker.hasTasks() : !worker._runningIsolatedTask;\n  }).sort(leastTotalRunningTime)[0];\n  if (!worker) {\n    if (!queued) tasks.push(task);\n    return false;\n  } else {\n    assert(task.isolated ? !worker.hasTasks() : true);\n    debug(\"found free worker\", worker._id, \"for task\", task.id);\n    worker.performTask(task);\n    return true;\n  }\n}",
    "snippets": [
      "Promise.setScheduler(function(function fn) scheduler) -> function\n",
      "// This is just an example of how to use the api, there is no reason to do this\nPromise.setScheduler(function(fn) {\n    setTimeout(fn, 0);\n});\n",
      "// This will synchronize bluebird promise queue flushing with angulars queue flushing\n// Angular is also now responsible for choosing the actual scheduler\nPromise.setScheduler(function(fn) {\n    $rootScope.$evalAsync(fn);\n});\n"
    ],
    "comments": []
  },
  "some": {
    "params": [
      "fun"
    ],
    "body": "{\n  var object = toObject(this), self = splitString && _toString(this) == \"[object String]\" ? this.split(\"\") : object, length = self.length >>> 0, thisp = arguments[1];\n  if (_toString(fun) != \"[object Function]\") {\n    throw new TypeError(fun + \" is not a function\");\n  }\n  for (var i = 0; i < length; i++) {\n    if ((i in self) && fun.call(thisp, self[i], i, object)) {\n      return true;\n    }\n  }\n  return false;\n}",
    "snippets": [
      ".some(int count) -> Promise\n"
    ],
    "comments": []
  },
  "PromiseInspection": {
    "params": [
      "promise"
    ],
    "body": "{\n  this._bitField = promise._bitField;\n  this._resolvedValue = promise.isResolved() ? promise._resolvedValue : void 0;\n}",
    "snippets": [
      "interface PromiseInspection {\n    any reason()\n    any value()\n    boolean isPending()\n    boolean isRejected()\n    boolean isFulfilled()\n    boolean isCancelled()\n}\n"
    ],
    "comments": []
  },
  "resolve": {
    "params": [
      "item"
    ],
    "body": "{\n  item[1](item[2]);\n}",
    "snippets": [
      "Promise.resolve(Promise<any>|any value) -> Promise\n",
      "var someCachedValue;\n\nvar getValue = function() {\n    if (someCachedValue) {\n        return Promise.resolve(someCachedValue);\n    }\n\n    return db.queryAsync().then(function(value) {\n        someCachedValue = value;\n        return value;\n    });\n};\n",
      "Promise.resolve($.get(\"http://www.google.com\")).then(function() {\n    //Returning a thenable from a handler is automatically\n    //cast to a trusted Promise as per Promises/A+ specification\n    return $.post(\"http://www.yahoo.com\");\n}).then(function() {\n\n}).catch(function(e) {\n    //jQuery doesn't throw real errors so use catch-all\n    console.log(e.statusText);\n});\n"
    ],
    "comments": []
  },
  "reject": {
    "params": [
      "reason"
    ],
    "body": "{\n  if (!promise) return;\n  promise._rejectCallback(reason, synchronous, true);\n  promise = null;\n}",
    "snippets": [
      ".suppressUnhandledRejections() -> undefined\n",
      "somePromise.catch(function(){});\n",
      "var tweets = fetchTweets();\n$(document).on(\"ready\", function() {\n    tweets.then(function() {\n        // Render tweets\n    }).catch(function(e) {\n        alert(\"failed to fetch tweets because: \" + e);\n    });\n});\n",
      "var tweets = fetchTweets();\ntweets.suppressUnhandledRejections();\n$(document).on(\"ready\", function() {\n    tweets.then(function() {\n        // Render tweets\n    }).catch(function(e) {\n        alert(\"failed to fetch tweets because: \" + e);\n    });\n});\n",
      "fetchTweets()\n    .finally(function() {\n        return $.ready.promise();\n    })\n    // DOM guaranteed to be ready after this point\n    .then(function() {\n        // Render tweets\n    })\n    .catch(function(e) {\n        alert(\"failed to fetch tweets because: \" + e);\n    });\n"
    ],
    "comments": []
  },
  "dispose": {
    "params": [
      "resources",
      "inspection"
    ],
    "body": "{\n  var i = 0;\n  var len = resources.length;\n  var ret = new Promise(INTERNAL);\n  function iterator() {\n    if (i >= len) return ret._fulfill();\n    var maybePromise = castPreservingDisposable(resources[i++]);\n    if (maybePromise instanceof Promise && maybePromise._isDisposable()) {\n      try {\n        maybePromise = tryConvertToPromise(maybePromise._getDisposer().tryDispose(inspection), resources.promise);\n      } catch (e) {\n        return thrower(e);\n      }\n      if (maybePromise instanceof Promise) {\n        return maybePromise._then(iterator, thrower, null, null, null);\n      }\n    }\n    iterator();\n  }\n  iterator();\n  return ret;\n}",
    "snippets": [
      ".disposer(function(any resource, Promise usingOutcomePromise) disposer) -> Disposer\n",
      "// This function doesn't return a promise but a Disposer\n// so it's very hard to use it wrong (not passing it to `using`)\nfunction getConnection() {\n    return db.connect().disposer(function(connection, promise) {\n        connection.close();\n    });\n}\n",
      "function useConnection(query) {\n  return Promise.using(getConnection(), function(connection) {\n    return connection.sendQuery(query).then(function(results) {\n      return process(results);\n    })\n  });\n}\n",
      "var pg = require(\"pg\");\n// Uncomment if pg has not been properly promisified yet\n//var Promise = require(\"bluebird\");\n//Promise.promisifyAll(pg, {\n//    filter: function(methodName) {\n//        return methodName === \"connect\"\n//    },\n//    multiArgs: true\n//});\n// Promisify rest of pg normally\n//Promise.promisifyAll(pg);\n\nfunction getSqlConnection(connectionString) {\n    var close;\n    return pg.connectAsync(connectionString).spread(function(client, done) {\n        close = done;\n        return client;\n    }).disposer(function() {\n        if (close) close();\n    });\n}\n\nmodule.exports = getSqlConnection;\n",
      "var mysql = require(\"mysql\");\n// Uncomment if mysql has not been properly promisified yet\n// var Promise = require(\"bluebird\");\n// Promise.promisifyAll(mysql);\n// Promise.promisifyAll(require(\"mysql/lib/Connection\").prototype);\n// Promise.promisifyAll(require(\"mysql/lib/Pool\").prototype);\nvar pool  = mysql.createPool({\n    connectionLimit: 10,\n    host: 'example.org',\n    user: 'bob',\n    password: 'secret'\n});\n\nfunction getSqlConnection() {\n    return pool.getConnectionAsync().disposer(function(connection) {\n        connection.release();\n    });\n}\n\nmodule.exports = getSqlConnection;\n",
      "function withTransaction(fn) {\n  return Promise.using(pool.acquireConnection(), function(connection) {\n    var tx = connection.beginTransaction()\n    return Promise\n      .try(fn, tx)\n      .then(function(res) { return connection.commit().thenReturn(res) },\n            function(err) {\n              return connection.rollback()\n                     .catch(function(e) {/* maybe add the rollback error to err */})\n                     .thenThrow(err);\n            });\n  });\n}\n\n// If the withTransaction block completes successfully, the transaction is automatically committed\n// Any error or rejection will automatically roll it back\n\nwithTransaction(function(tx) {\n    return tx.queryAsync(...).then(function() {\n        return tx.queryAsync(...)\n    }).then(function() {\n        return tx.queryAsync(...)\n    });\n});\n"
    ],
    "comments": []
  },
  "T": {
    "params": [],
    "body": "{\n  this.constructor = Child;\n  this.constructor$ = Parent;\n  for (var propertyName in Parent.prototype) {\n    if (hasProp.call(Parent.prototype, propertyName) && propertyName.charAt(propertyName.length - 1) !== \"$\") {\n      this[propertyName + \"$\"] = Parent.prototype[propertyName];\n    }\n  }\n}",
    "snippets": [],
    "comments": []
  },
  "env": {
    "params": [
      "key"
    ],
    "body": "{\n  return hasEnvVariables ? process.env[key] : undefined;\n}",
    "snippets": [],
    "comments": []
  },
  "bind": {
    "params": [
      "fn",
      "ctx"
    ],
    "body": "{\n  return function () {\n    return fn.apply(ctx, arguments);\n  };\n}",
    "snippets": [
      "Promise.bind(\n    any|Promise<any> thisArg,\n    [any|Promise<any> value=undefined]\n) -> BoundPromise\n",
      "MyClass.prototype.method = function() {\n    try {\n        var contents = fs.readFileSync(this.file);\n        var url = urlParse(contents);\n        var result = this.httpGetSync(url);\n        var refined = this.refine(result);\n        return this.writeRefinedSync(refined);\n    }\n    catch (e) {\n        this.error(e.stack);\n    }\n};\n",
      "MyClass.prototype.method = function() {\n    return fs.readFileAsync(this.file).bind(this)\n    .then(function(contents) {\n        var url = urlParse(contents);\n        return this.httpGetAsync(url);\n    }).then(function(result) {\n        var refined = this.refine(result);\n        return this.writeRefinedAsync(refined);\n    }).catch(function(e) {\n        this.error(e.stack);\n    });\n};\n",
      "somethingAsync().bind({})\n.spread(function (aValue, bValue) {\n    this.aValue = aValue;\n    this.bValue = bValue;\n    return somethingElseAsync(aValue, bValue);\n})\n.then(function (cValue) {\n    return this.aValue + this.bValue + cValue;\n});\n",
      "var scope = {};\nsomethingAsync()\n.spread(function (aValue, bValue) {\n    scope.aValue = aValue;\n    scope.bValue = bValue;\n    return somethingElseAsync(aValue, bValue);\n})\n.then(function (cValue) {\n    return scope.aValue + scope.bValue + cValue;\n});\n",
      "something().bind(var1).then(function() {\n    //`this` is var1 here\n    return Promise.all(getStuff()).then(function(results) {\n        //`this` is undefined here\n        //refine results here etc\n    });\n}).then(function() {\n    //`this` is var1 here\n});\n",
      "something().bind(var1).then(function() {\n    //`this` is var1 here\n    return getStuff();\n}).map(function(result) {\n    //`this` is var1 here\n    //refine result here\n}).then(function() {\n    //`this` is var1 here\n});\n",
      "MyClass.prototype.method = function() {\n    return fs.readFileAsync(this.file).bind(this)\n    .then(function(contents) {\n        var url = urlParse(contents);\n        return this.httpGetAsync(url);\n    }).then(function(result) {\n        var refined = this.refine(result);\n        return this.writeRefinedAsync(refined);\n    }).catch(function(e) {\n        this.error(e.stack);\n    }).bind(); //The `thisArg` is implicitly undefined - I.E. the default promise `this` value\n};\n",
      "Promise.resolve(\"my-element\")\n    .bind(document)\n    .then(document.getElementById)\n    .bind(console)\n    .then(console.log);\n"
    ],
    "comments": []
  },
  "filter": {
    "params": [
      "fun"
    ],
    "body": "{\n  var object = toObject(this), self = splitString && _toString(this) == \"[object String]\" ? this.split(\"\") : object, length = self.length >>> 0, result = [], value, thisp = arguments[1];\n  if (_toString(fun) != \"[object Function]\") {\n    throw new TypeError(fun + \" is not a function\");\n  }\n  for (var i = 0; i < length; i++) {\n    if ((i in self)) {\n      value = self[i];\n      if (fun.call(thisp, value, i, object)) {\n        result.push(value);\n      }\n    }\n  }\n  return result;\n}",
    "snippets": [
      "Promise.filter(\n    Iterable<any>|Promise<Iterable<any>> input,\n    function(any item, int index, int length) filterer,\n    [Object {concurrency: int=Infinity} options]\n) -> Promise\n",
      "Promise.map(valuesToBeFiltered, function(value, index, length) {\n    return Promise.all([filterer(value, index, length), value]);\n}).then(function(values) {\n    return values.filter(function(stuff) {\n        return stuff[0] == true\n    }).map(function(stuff) {\n        return stuff[1];\n    });\n});\n",
      "var Promise = require(\"bluebird\");\nvar E = require(\"core-error-predicates\");\nvar fs = Promise.promisifyAll(require(\"fs\"));\n\nfs.readdirAsync(process.cwd()).filter(function(fileName) {\n    return fs.statAsync(fileName)\n        .then(function(stat) {\n            return stat.isDirectory();\n        })\n        .catch(E.FileAccessError, function() {\n            return false;\n        });\n}).each(function(directoryName) {\n    console.log(directoryName, \" is an accessible directory\");\n});\n"
    ],
    "comments": []
  },
  "log": {
    "params": [
      "value"
    ],
    "body": "{\n  process.stdout.write(value.stdout);\n  process.stderr.write(value.stderr);\n}",
    "snippets": [],
    "comments": []
  },
  "s": {
    "params": [
      "a"
    ],
    "body": "{\n  if (s[a] !== v) return s[a];\n  var c;\n  if (\"bug-string-char-index\" == a) c = \"a\" != (\"a\")[0]; else if (\"json\" == a) c = s(\"json-stringify\") && s(\"json-parse\"); else {\n    var e;\n    if (\"json-stringify\" == a) {\n      c = q.stringify;\n      var b = \"function\" == typeof c && r;\n      if (b) {\n        (e = function () {\n          return 1;\n        }).toJSON = e;\n        try {\n          b = \"0\" === c(0) && \"0\" === c(new A()) && '\"\"' == c(new B()) && c(t) === v && c(v) === v && c() === v && \"1\" === c(e) && \"[1]\" == c([e]) && \"[null]\" == c([v]) && \"null\" == c(null) && \"[null,null,null]\" == c([v, t, null]) && '{\"a\":[1,true,false,null,\"\\\\u0000\\\\b\\\\n\\\\f\\\\r\\\\t\"]}' == c({\n            a: [e, !0, !1, null, \"\\x00\\b\\n\\f\\r\\t\"]\n          }) && \"1\" === c(null, e) && \"[\\n 1,\\n 2\\n]\" == c([1, 2], null, 1) && '\"-271821-04-20T00:00:00.000Z\"' == c(new D(-864E13)) && '\"+275760-09-13T00:00:00.000Z\"' == c(new D(864E13)) && '\"-000001-01-01T00:00:00.000Z\"' == c(new D(-621987552E5)) && '\"1969-12-31T23:59:59.999Z\"' == c(new D(-1));\n        } catch (f) {\n          b = !1;\n        }\n      }\n      c = b;\n    }\n    if (\"json-parse\" == a) {\n      c = q.parse;\n      if (\"function\" == typeof c) try {\n        if (0 === c(\"0\") && !c(!1)) {\n          e = c('{\"a\":[1,true,false,null,\"\\\\u0000\\\\b\\\\n\\\\f\\\\r\\\\t\"]}');\n          var l = 5 == e.a.length && 1 === e.a[0];\n          if (l) {\n            try {\n              l = !c('\"\\t\"');\n            } catch (d) {}\n            if (l) try {\n              l = 1 !== c(\"01\");\n            } catch (h) {}\n            if (l) try {\n              l = 1 !== c(\"1.\");\n            } catch (m) {}\n          }\n        }\n      } catch (X) {\n        l = !1;\n      }\n      c = l;\n    }\n  }\n  return s[a] = !!c;\n}",
    "snippets": [],
    "comments": []
  },
  "on": {
    "params": [
      "el",
      "event",
      "fn"
    ],
    "body": "{\n  if (el.addEventListener) {\n    el.addEventListener(event, fn, false);\n  } else {\n    el.attachEvent('on' + event, fn);\n  }\n}",
    "snippets": [
      "function processImage(image) {\n    // Code that processes image\n}\n\ngetImage().then(processImage());\n",
      "getImage().then(processImage)\n",
      "getUser().then(function(user) {\n    getUserData(user);\n}).then(function(userData) {\n    // userData is undefined\n});\n",
      "getUser().then(function(user) {\n    return getUserData(user);\n}).then(function(userData) {\n    // userData is the user's data\n});\n",
      "getUser().then(function(user) {\n    // Perform this in the \"background\" and don't care about its result at all\n    saveAnalytics(user);\n    // return a non-undefined value to signal that we didn't forget to return\n    return null;\n});\n"
    ],
    "comments": [
      "Warning: a promise was rejected with a non-error",
      "Warning: a promise was created in a handler but was not returned from it"
    ]
  },
  "Progress": {
    "params": [
      "runner",
      "options"
    ],
    "body": "{\n  Base.call(this, runner);\n  var self = this, options = options || ({}), stats = this.stats, width = Base.window.width * .50 | 0, total = runner.total, complete = 0, max = Math.max, lastN = -1;\n  options.open = options.open || '[';\n  options.complete = options.complete || '▬';\n  options.incomplete = options.incomplete || Base.symbols.dot;\n  options.close = options.close || ']';\n  options.verbose = false;\n  runner.on('start', function () {\n    console.log();\n    cursor.hide();\n  });\n  runner.on('test end', function () {\n    complete++;\n    var incomplete = total - complete, percent = complete / total, n = width * percent | 0, i = width - n;\n    if (lastN === n && !options.verbose) {\n      return;\n    }\n    lastN = n;\n    cursor.CR();\n    process.stdout.write('\\u001b[J');\n    process.stdout.write(color('progress', '  ' + options.open));\n    process.stdout.write(Array(n).join(options.complete));\n    process.stdout.write(Array(i).join(options.incomplete));\n    process.stdout.write(color('progress', options.close));\n    if (options.verbose) {\n      process.stdout.write(color('progress', ' ' + complete + ' of ' + total));\n    }\n  });\n  runner.on('end', function () {\n    cursor.show();\n    console.log();\n    self.epilogue();\n  });\n}",
    "snippets": [
      "Promise.resolve($.get(...))\n    .progressed(function() {\n        // ...\n    })\n    .then(function() {\n        // ...\n    })\n    .catch(function(e) {\n        // ...\n    })\n",
      "Promise.resolve($.get(...).progress(function() {\n        // ...\n    }))\n    .then(function() {\n        // ...\n    })\n    .catch(function(e) {\n        // ...\n    })\n",
      "function returnsPromiseWithProgress(progressHandler) {\n    return doFirstAction().tap(function() {\n        progressHandler(0.33);\n    }).then(doSecondAction).tap(function() {\n        progressHandler(0.66);\n    }).then(doThirdAction).tap(function() {\n        progressHandler(1.00);\n    });\n}\n\nreturnsPromiseWithProgress(function(progress) {\n    ui.progressbar.setWidth((progress * 200) + \"px\"); // update width on client side\n}).then(function(value) { // action complete\n   // entire chain is complete.\n}).catch(function(e) {\n    // error\n});\n",
      "var doNothing = function() {};\nvar progressSupportingCoroutine = Promise.coroutine(function* (progress) {\n        progress = typeof progress === \"function\" ? progress : doNothing;\n        var first = yield getFirstValue();\n        // 33% done\n        progress(0.33);\n        var second = yield getSecondValue();\n        progress(0.67);\n        var third = yield getThirdValue();\n        progress(1);\n        return [first, second, third];\n});\n\nvar progressConsumingCoroutine = Promise.coroutine(function* () {\n    var allValues = yield progressSupportingCoroutine(function(p) {\n         ui.progressbar.setWidth((p * 200) + \"px\");\n    });\n    var second = allValues[1];\n    // ...\n});\n"
    ],
    "comments": []
  },
  "F": {
    "params": [],
    "body": "{}",
    "snippets": [
      "var fs = require(\"fs\");\nPromise.promisifyAll(fs);\n// Now you can use fs as if it was designed to use bluebird promises from the beginning\n\nfs.readFileAsync(\"file.js\", \"utf8\").then(...)\n",
      "// The most popular redis module\nvar Promise = require(\"bluebird\");\nPromise.promisifyAll(require(\"redis\"));\n",
      "// The most popular mongodb module\nvar Promise = require(\"bluebird\");\nPromise.promisifyAll(require(\"mongodb\"));\n",
      "// The most popular mysql module\nvar Promise = require(\"bluebird\");\n// Note that the library's classes are not properties of the main export\n// so we require and promisifyAll them manually\nPromise.promisifyAll(require(\"mysql/lib/Connection\").prototype);\nPromise.promisifyAll(require(\"mysql/lib/Pool\").prototype);\n",
      "// Mongoose\nvar Promise = require(\"bluebird\");\nPromise.promisifyAll(require(\"mongoose\"));\n",
      "// Request\nvar Promise = require(\"bluebird\");\nPromise.promisifyAll(require(\"request\"));\n// Use request.getAsync(...) not request(..), it will not return a promise\n",
      "// mkdir\nvar Promise = require(\"bluebird\");\nPromise.promisifyAll(require(\"mkdirp\"));\n// Use mkdirp.mkdirpAsync not mkdirp(..), it will not return a promise\n",
      "// winston\nvar Promise = require(\"bluebird\");\nPromise.promisifyAll(require(\"winston\"));\n",
      "// rimraf\nvar Promise = require(\"bluebird\");\n// The module isn't promisified but the function returned is\nvar rimrafAsync = Promise.promisify(require(\"rimraf\"));\n",
      "// xml2js\nvar Promise = require(\"bluebird\");\nPromise.promisifyAll(require(\"xml2js\"));\n",
      "// jsdom\nvar Promise = require(\"bluebird\");\nPromise.promisifyAll(require(\"jsdom\"));\n",
      "// fs-extra\nvar Promise = require(\"bluebird\");\nPromise.promisifyAll(require(\"fs-extra\"));\n",
      "// prompt\nvar Promise = require(\"bluebird\");\nPromise.promisifyAll(require(\"prompt\"));\n",
      "// Nodemailer\nvar Promise = require(\"bluebird\");\nPromise.promisifyAll(require(\"nodemailer\"));\n",
      "// ncp\nvar Promise = require(\"bluebird\");\nPromise.promisifyAll(require(\"ncp\"));\n",
      "// pg\nvar Promise = require(\"bluebird\");\nPromise.promisifyAll(require(\"pg\"));\n",
      "var ParanoidLib = require(\"...\");\nvar throwAwayInstance = ParanoidLib.createInstance();\nPromise.promisifyAll(Object.getPrototypeOf(throwAwayInstance));\n// Like before, from this point on, all new instances + even the throwAwayInstance suddenly support promises\n",
      "setTimeout(function() {\n    setTimeout(function() {\n        setTimeout(function() {\n            a.b.c;\n        }, 1);\n    }, 1)\n}, 1)\n",
      "ReferenceError: a is not defined\n    at null._onTimeout file.js:4:13\n    at Timer.listOnTimeout (timers.js:90:15)\n",
      "var Promise = require(\"bluebird\");\n\nPromise.delay(1)\n    .delay(1)\n    .delay(1).then(function() {\n        a.b.c;\n    });\n",
      "Unhandled rejection ReferenceError: a is not defined\n    at file.js:6:9\n    at processImmediate [as _immediateCallback] (timers.js:321:17)\nFrom previous event:\n    at Object.<anonymous> (file.js:5:15)\n    at Module._compile (module.js:446:26)\n    at Object.Module._extensions..js (module.js:464:10)\n    at Module.load (module.js:341:32)\n    at Function.Module._load (module.js:296:12)\n    at Function.Module.runMain (module.js:487:10)\n    at startup (node.js:111:16)\n    at node.js:799:3\n",
      "// Note the event name is in camelCase, as per Node.js convention.\nprocess.on(\"promiseChained\", function(promise, child) {\n    // promise - The parent promise the child was chained from\n    // child - The created child promise.\n});\n",
      "// Note the event names are in mashedtogetherlowercase, as per DOM convention.\nself.addEventListener(\"promisechained\", function(event) {\n    // event.details.promise - The parent promise the child was chained from\n    // event.details.child - The created child promise.\n});\n",
      "// Note the event names are in mashedtogetherlowercase, as per legacy convention.\nwindow.onpromisechained = function(promise, child) {\n    // event.details.promise - The parent promise the child was chained from\n    // event.details.child - The created child promise.\n};\n",
      "// Enable cancellation\nPromise.config({cancellation: true});\n\nvar fs = Promise.promisifyAll(require(\"fs\"));\n\n// In 2000ms or less, load & parse a file 'config.json'\nvar p = Promise.resolve('./config.json')\n .timeout(2000)\n .catch(console.error.bind(console, 'Failed to load config!'))\n .then(fs.readFileAsync)\n .then(JSON.parse);\n// Listen for exception event to trigger promise cancellation\nprocess.on('unhandledException', function(event) {\n // cancel config loading\n p.cancel();\n});\n",
      "                //NOTE the function call right after\nmodule.exports = require(\"bluebird/js/main/promise\")();\n"
    ],
    "comments": []
  },
  "error": {
    "params": [
      "msg"
    ],
    "body": "{\n  document.body.appendChild(fragment('<div id=\"mocha-error\">%s</div>', msg));\n}",
    "snippets": [],
    "comments": []
  },
  "title": {
    "params": [
      "test"
    ],
    "body": "{\n  return test.fullTitle().replace(/#/g, '');\n}",
    "snippets": [
      "function getStuff(data, callback) {\n    ...\n}\n\ngetStuff(\"dataParam\", function(err, data) {\n    if (!err) {\n\n    }\n});\n",
      "// callbacks\nvar fs = require(\"fs\");\nfs.readFile(\"name\", \"utf8\", function(err, data) {\n\n});\n",
      "var fs = Promise.promisifyAll(require(\"fs\"));\nfs.readFileAsync(\"name\", \"utf8\").then(function(data) {\n\n});\n",
      "var request = Promise.promisify(require(\"request\"));\nrequest(\"foo.bar\").then(function(result) {\n\n});\n",
      "// onload example, the promise constructor takes a\n// 'resolver' function that tells the promise when\n// to resolve and fire off its `then` handlers.\nvar loaded = new Promise(function(resolve, reject) {\n    window.addEventListener(\"load\", resolve);\n});\n\nloaded.then(function() {\n    // window is loaded here\n});\n",
      "function connect() {\n   var connection = myConnector.getConnection();  // Synchronous.\n   return new Promise(function(resolve, reject) {\n        connection.on(\"ready\", function() {\n            // When a connection has been established\n            // mark the promise as fulfilled.\n            resolve(connection);\n        });\n        connection.on(\"error\", function(e) {\n            // If it failed connecting, mark it\n            // as rejected.\n            reject(e);  // e is preferably an `Error`.\n        });\n   });\n}\n",
      "function connect() {\n   return new Promise(function(resolve, reject) {\n        // If getConnection throws here instead of getting\n        // an exception we're getting a rejection thus\n        // producing a much more consistent API.\n        var connection = myConnector.getConnection();\n        connection.on(\"ready\", function() {\n            // When a connection has been established\n            // mark the promise as fulfilled.\n            resolve(connection);\n        });\n        connection.on(\"error\", function(e) {\n            // If it failed connecting, mark it\n            // as rejected.\n            reject(e); //  e is preferably an `Error`\n        });\n   });\n}\n",
      "var Mongoose = Promise.promisifyAll(require(\"mongoose\"));\n",
      "var pg = require(\"pg\");\n// Uncomment if pg has not been properly promisified yet.\n//var Promise = require(\"bluebird\");\n//Promise.promisifyAll(pg, {\n//    filter: function(methodName) {\n//        return methodName === \"connect\"\n//    },\n//    multiArgs: true\n//});\n// Promisify rest of pg normally.\n//Promise.promisifyAll(pg);\n\nfunction getSqlConnection(connectionString) {\n    var close;\n    return pg.connectAsync(connectionString).spread(function(client, done) {\n        close = done;\n        return client;\n    }).disposer(function() {\n        if (close) close();\n    });\n}\n\nmodule.exports = getSqlConnection;\n",
      "var using = Promise.using;\n\nusing(getSqlConnection(), function(conn) {\n    // use connection here and _return the promise_\n\n}).then(function(result) {\n    // connection already disposed here\n\n});\n",
      "\nfunction withTransaction(fn) {\n  return Promise.using(pool.acquireConnection(), function(connection) {\n    var tx = connection.beginTransaction()\n    return Promise\n      .try(fn, tx)\n      .then(function(res) { return connection.commit().thenReturn(res) },\n            function(err) {\n              return connection.rollback()\n                     .catch(function(e) {/* maybe add the rollback error to err */})\n                     .thenThrow(err);\n            });\n  });\n}\nexports.withTransaction = withTransaction;\n",
      "withTransaction(tx => {\n    return tx.queryAsync(...).then(function() {\n        return tx.queryAsync(...)\n    }).then(function() {\n        return tx.queryAsync(...)\n    });\n});\n",
      "var mysql = require(\"mysql\");\n// Uncomment if mysql has not been properly promisified yet\n// var Promise = require(\"bluebird\");\n// Promise.promisifyAll(mysql);\n// Promise.promisifyAll(require(\"mysql/lib/Connection\").prototype);\n// Promise.promisifyAll(require(\"mysql/lib/Pool\").prototype);\nvar pool  = mysql.createPool({\n    connectionLimit: 10,\n    host: 'example.org',\n    user: 'bob',\n    password: 'secret'\n});\n\nfunction getSqlConnection() {\n    return pool.getConnectionAsync().disposer(function(connection) {\n        connection.release();\n    });\n}\n\nmodule.exports = getSqlConnection;\n",
      "// The most popular redis module\nvar Promise = require(\"bluebird\");\nPromise.promisifyAll(require(\"redis\"));\n",
      "// The most popular mongodb module\nvar Promise = require(\"bluebird\");\nPromise.promisifyAll(require(\"mongodb\"));\n",
      "// The most popular mysql module\nvar Promise = require(\"bluebird\");\n// Note that the library's classes are not properties of the main export\n// so we require and promisifyAll them manually\nPromise.promisifyAll(require(\"mysql/lib/Connection\").prototype);\nPromise.promisifyAll(require(\"mysql/lib/Pool\").prototype);\n",
      "// Mongoose\nvar Promise = require(\"bluebird\");\nPromise.promisifyAll(require(\"mongoose\"));\n",
      "// Request\nvar Promise = require(\"bluebird\");\nPromise.promisifyAll(require(\"request\"));\n// Use request.getAsync(...) not request(..), it will not return a promise\n",
      "// mkdir\nvar Promise = require(\"bluebird\");\nPromise.promisifyAll(require(\"mkdirp\"));\n// Use mkdirp.mkdirpAsync not mkdirp(..), it will not return a promise\n",
      "// winston\nvar Promise = require(\"bluebird\");\nPromise.promisifyAll(require(\"winston\"));\n",
      "// rimraf\nvar Promise = require(\"bluebird\");\n// The module isn't promisified but the function returned is\nvar rimrafAsync = Promise.promisify(require(\"rimraf\"));\n",
      "// xml2js\nvar Promise = require(\"bluebird\");\nPromise.promisifyAll(require(\"xml2js\"));\n",
      "// jsdom\nvar Promise = require(\"bluebird\");\nPromise.promisifyAll(require(\"jsdom\"));\n",
      "// fs-extra\nvar Promise = require(\"bluebird\");\nPromise.promisifyAll(require(\"fs-extra\"));\n",
      "// prompt\nvar Promise = require(\"bluebird\");\nPromise.promisifyAll(require(\"prompt\"));\n",
      "// Nodemailer\nvar Promise = require(\"bluebird\");\nPromise.promisifyAll(require(\"nodemailer\"));\n",
      "// ncp\nvar Promise = require(\"bluebird\");\nPromise.promisifyAll(require(\"ncp\"));\n",
      "// pg\nvar Promise = require(\"bluebird\");\nPromise.promisifyAll(require(\"pg\"));\n",
      "var ParanoidLib = require(\"...\");\nvar throwAwayInstance = ParanoidLib.createInstance();\nPromise.promisifyAll(Object.getPrototypeOf(throwAwayInstance));\n// Like before, from this point on, all new instances + even the throwAwayInstance suddenly support promises\n",
      "function getUserData(userId, onLoad, onFail) { ...\n",
      "function getUserDataAsync(userId) {\n    return new Promise(function(resolve, reject) {\n        // Put all your code here, this section is throw-safe.\n        getUserData(userId, resolve, reject);\n    });\n}\n"
    ],
    "comments": []
  },
  "done": {
    "params": [
      "err"
    ],
    "body": "{\n  if (err) {\n    return next(err);\n  }\n  if (--limit <= 0) {\n    next();\n  }\n}",
    "snippets": [
      ".done(\n    [function(any value) fulfilledHandler],\n    [function(any error) rejectedHandler]\n) -> undefined\n"
    ],
    "comments": []
  },
  "handler": {
    "params": [
      "ev"
    ],
    "body": "{\n  ev.preventDefault();\n  self.postMessage(ev.type);\n  if (ev.type === \"unhandledrejection\") {\n    currentPromise.catch(function () {});\n  }\n}",
    "snippets": [
      "Promise.coroutine.addYieldHandler(function handler) -> undefined\n",
      "Promise.coroutine.addYieldHandler(function(value) {\n     if (typeof value === \"number\") return Promise.delay(value);\n});\n",
      "var Promise = require(\"bluebird\");\nvar fs = require(\"fs\");\n\nvar _ = (function() {\n    var promise = null;\n    Promise.coroutine.addYieldHandler(function(v) {\n        if (v === undefined && promise != null) {\n            return promise;\n        }\n        promise = null;\n    });\n    return function() {\n        var def = Promise.defer();\n        promise = def.promise;\n        return def.callback;\n    };\n})();\n\n\nvar readFileJSON = Promise.coroutine(function* (fileName) {\n   var contents = yield fs.readFile(fileName, \"utf8\", _());\n   return JSON.parse(contents);\n});\n",
      "var Promise = require(\"bluebird\");\nvar fs = require(\"fs\");\n\nPromise.coroutine.addYieldHandler(function(v) {\n    if (typeof v === \"function\") {\n        return Promise.fromCallback(function(cb) {\n            v(cb);\n        });\n    }\n});\n\nvar readFileThunk = function(fileName, encoding) {\n    return function(cb) {\n        return fs.readFile(fileName, encoding, cb);\n    };\n};\n\nvar readFileJSON = Promise.coroutine(function* (fileName) {\n   var contents = yield readFileThunk(fileName, \"utf8\");\n   return JSON.parse(contents);\n});\n",
      "var Promise = require(\"bluebird\");\nvar fs = Promise.promisifyAll(require(\"fs\"));\n\nPromise.coroutine.addYieldHandler(function(yieldedValue) {\n    if (Array.isArray(yieldedValue)) return Promise.all(yieldedValue);\n});\n\nvar readFiles = Promise.coroutine(function* (fileNames) {\n   return yield fileNames.map(function (fileName) {\n      return fs.readFileAsync(fileName, \"utf8\");\n   });\n});\n",
      "var Promise = require(\"bluebird\");\nvar fs = Promise.promisifyAll(require(\"fs\"));\n\nvar readFiles = Promise.coroutine(function* (fileNames) {\n   return yield fileNames.map(function (fileName) {\n      return fs.readFileAsync(fileName, \"utf8\");\n   });\n}, {\n   yieldHandler: function(yieldedValue) {\n      if (Array.isArray(yieldedValue)) return Promise.all(yieldedValue);\n   }\n});\n"
    ],
    "comments": []
  },
  "x": {
    "params": [],
    "body": "{}",
    "snippets": [],
    "comments": []
  },
  "promise": {
    "params": [
      "obj"
    ],
    "body": "{\n  var d = Promise.defer();\n  setTimeout(function () {\n    d.resolve(3);\n  }, 1);\n  specify(\"promise for non-collection value\", function () {\n    return getPromise(obj, d.promise).then(assert.fail).caught(Promise.TypeError, testUtils.returnToken).then(testUtils.assertToken);\n  });\n}",
    "snippets": [
      "fs.readFile(\"file.json\", function (err, val) {\n    if (err) {\n        console.error(\"unable to read file\");\n    }\n    else {\n        try {\n            val = JSON.parse(val);\n            console.log(val.success);\n        }\n        catch (e) {\n            console.error(\"invalid json in file\");\n        }\n    }\n});\n",
      "fs.readFileAsync(\"file.json\").then(JSON.parse).then(function (val) {\n    console.log(val.success);\n})\n.catch(SyntaxError, function (e) {\n    console.error(\"invalid json in file\");\n})\n.catch(function (e) {\n    console.error(\"unable to read file\");\n});\n",
      "try {\n    var val = JSON.parse(fs.readFileSync(\"file.json\"));\n    console.log(val.success);\n}\n// Gecko-only syntax; used for illustrative purposes\ncatch (e if e instanceof SyntaxError) {\n    console.error(\"invalid json in file\");\n}\ncatch (e) {\n    console.error(\"unable to read file\");\n}\n",
      "//Copyright Plato http://stackoverflow.com/a/19385911/995876\n//CC BY-SA 2.5\nmapSeries(URLs, function (URL, done) {\n    var options = {};\n    needle.get(URL, options, function (error, response, body) {\n        if (error) {\n            return done(error);\n        }\n        try {\n            var ret = JSON.parse(body);\n            return done(null, ret);\n        }\n        catch (e) {\n            done(e);\n        }\n    });\n}, function (err, results) {\n    if (err) {\n        console.log(err);\n    } else {\n        console.log('All Needle requests successful');\n        // results is a 1 to 1 mapping in order of URLs > needle.body\n        processAndSaveAllInDB(results, function (err) {\n            if (err) {\n                return done(err);\n            }\n            console.log('All Needle requests saved');\n            done(null);\n        });\n    }\n});\n",
      "Promise.promisifyAll(needle);\nvar options = {};\n\nvar current = Promise.resolve();\nPromise.map(URLs, function (URL) {\n    current = current.then(function () {\n        return needle.getAsync(URL, options);\n    });\n    return current;\n}).map(function (responseAndBody) {\n    return JSON.parse(responseAndBody[1]);\n}).then(function (results) {\n    return processAndSaveAllInDB(results);\n}).then(function () {\n    console.log('All Needle requests saved');\n}).catch(function (e) {\n    console.log(e);\n});\n"
    ],
    "comments": []
  },
  "a": {
    "params": [],
    "body": "{\n  return Promise.join(Promise.resolve(1), function () {\n    throw new Error();\n  });\n}",
    "snippets": [],
    "comments": []
  },
  "b": {
    "params": [],
    "body": "{\n  arr.push(2);\n}",
    "snippets": [
      "function getStuff(data, callback) {\n    ...\n}\n\ngetStuff(\"dataParam\", function(err, data) {\n    if (!err) {\n\n    }\n});\n",
      "// callbacks\nvar fs = require(\"fs\");\nfs.readFile(\"name\", \"utf8\", function(err, data) {\n\n});\n",
      "var fs = Promise.promisifyAll(require(\"fs\"));\nfs.readFileAsync(\"name\", \"utf8\").then(function(data) {\n\n});\n",
      "var request = Promise.promisify(require(\"request\"));\nrequest(\"foo.bar\").then(function(result) {\n\n});\n",
      "// onload example, the promise constructor takes a\n// 'resolver' function that tells the promise when\n// to resolve and fire off its `then` handlers.\nvar loaded = new Promise(function(resolve, reject) {\n    window.addEventListener(\"load\", resolve);\n});\n\nloaded.then(function() {\n    // window is loaded here\n});\n",
      "function connect() {\n   var connection = myConnector.getConnection();  // Synchronous.\n   return new Promise(function(resolve, reject) {\n        connection.on(\"ready\", function() {\n            // When a connection has been established\n            // mark the promise as fulfilled.\n            resolve(connection);\n        });\n        connection.on(\"error\", function(e) {\n            // If it failed connecting, mark it\n            // as rejected.\n            reject(e);  // e is preferably an `Error`.\n        });\n   });\n}\n",
      "function connect() {\n   return new Promise(function(resolve, reject) {\n        // If getConnection throws here instead of getting\n        // an exception we're getting a rejection thus\n        // producing a much more consistent API.\n        var connection = myConnector.getConnection();\n        connection.on(\"ready\", function() {\n            // When a connection has been established\n            // mark the promise as fulfilled.\n            resolve(connection);\n        });\n        connection.on(\"error\", function(e) {\n            // If it failed connecting, mark it\n            // as rejected.\n            reject(e); //  e is preferably an `Error`\n        });\n   });\n}\n",
      "var Mongoose = Promise.promisifyAll(require(\"mongoose\"));\n",
      "var pg = require(\"pg\");\n// Uncomment if pg has not been properly promisified yet.\n//var Promise = require(\"bluebird\");\n//Promise.promisifyAll(pg, {\n//    filter: function(methodName) {\n//        return methodName === \"connect\"\n//    },\n//    multiArgs: true\n//});\n// Promisify rest of pg normally.\n//Promise.promisifyAll(pg);\n\nfunction getSqlConnection(connectionString) {\n    var close;\n    return pg.connectAsync(connectionString).spread(function(client, done) {\n        close = done;\n        return client;\n    }).disposer(function() {\n        if (close) close();\n    });\n}\n\nmodule.exports = getSqlConnection;\n",
      "var using = Promise.using;\n\nusing(getSqlConnection(), function(conn) {\n    // use connection here and _return the promise_\n\n}).then(function(result) {\n    // connection already disposed here\n\n});\n",
      "\nfunction withTransaction(fn) {\n  return Promise.using(pool.acquireConnection(), function(connection) {\n    var tx = connection.beginTransaction()\n    return Promise\n      .try(fn, tx)\n      .then(function(res) { return connection.commit().thenReturn(res) },\n            function(err) {\n              return connection.rollback()\n                     .catch(function(e) {/* maybe add the rollback error to err */})\n                     .thenThrow(err);\n            });\n  });\n}\nexports.withTransaction = withTransaction;\n",
      "withTransaction(tx => {\n    return tx.queryAsync(...).then(function() {\n        return tx.queryAsync(...)\n    }).then(function() {\n        return tx.queryAsync(...)\n    });\n});\n",
      "var mysql = require(\"mysql\");\n// Uncomment if mysql has not been properly promisified yet\n// var Promise = require(\"bluebird\");\n// Promise.promisifyAll(mysql);\n// Promise.promisifyAll(require(\"mysql/lib/Connection\").prototype);\n// Promise.promisifyAll(require(\"mysql/lib/Pool\").prototype);\nvar pool  = mysql.createPool({\n    connectionLimit: 10,\n    host: 'example.org',\n    user: 'bob',\n    password: 'secret'\n});\n\nfunction getSqlConnection() {\n    return pool.getConnectionAsync().disposer(function(connection) {\n        connection.release();\n    });\n}\n\nmodule.exports = getSqlConnection;\n",
      "// The most popular redis module\nvar Promise = require(\"bluebird\");\nPromise.promisifyAll(require(\"redis\"));\n",
      "// The most popular mongodb module\nvar Promise = require(\"bluebird\");\nPromise.promisifyAll(require(\"mongodb\"));\n",
      "// The most popular mysql module\nvar Promise = require(\"bluebird\");\n// Note that the library's classes are not properties of the main export\n// so we require and promisifyAll them manually\nPromise.promisifyAll(require(\"mysql/lib/Connection\").prototype);\nPromise.promisifyAll(require(\"mysql/lib/Pool\").prototype);\n",
      "// Mongoose\nvar Promise = require(\"bluebird\");\nPromise.promisifyAll(require(\"mongoose\"));\n",
      "// Request\nvar Promise = require(\"bluebird\");\nPromise.promisifyAll(require(\"request\"));\n// Use request.getAsync(...) not request(..), it will not return a promise\n",
      "// mkdir\nvar Promise = require(\"bluebird\");\nPromise.promisifyAll(require(\"mkdirp\"));\n// Use mkdirp.mkdirpAsync not mkdirp(..), it will not return a promise\n",
      "// winston\nvar Promise = require(\"bluebird\");\nPromise.promisifyAll(require(\"winston\"));\n",
      "// rimraf\nvar Promise = require(\"bluebird\");\n// The module isn't promisified but the function returned is\nvar rimrafAsync = Promise.promisify(require(\"rimraf\"));\n",
      "// xml2js\nvar Promise = require(\"bluebird\");\nPromise.promisifyAll(require(\"xml2js\"));\n",
      "// jsdom\nvar Promise = require(\"bluebird\");\nPromise.promisifyAll(require(\"jsdom\"));\n",
      "// fs-extra\nvar Promise = require(\"bluebird\");\nPromise.promisifyAll(require(\"fs-extra\"));\n",
      "// prompt\nvar Promise = require(\"bluebird\");\nPromise.promisifyAll(require(\"prompt\"));\n",
      "// Nodemailer\nvar Promise = require(\"bluebird\");\nPromise.promisifyAll(require(\"nodemailer\"));\n",
      "// ncp\nvar Promise = require(\"bluebird\");\nPromise.promisifyAll(require(\"ncp\"));\n",
      "// pg\nvar Promise = require(\"bluebird\");\nPromise.promisifyAll(require(\"pg\"));\n",
      "var ParanoidLib = require(\"...\");\nvar throwAwayInstance = ParanoidLib.createInstance();\nPromise.promisifyAll(Object.getPrototypeOf(throwAwayInstance));\n// Like before, from this point on, all new instances + even the throwAwayInstance suddenly support promises\n",
      "function getUserData(userId, onLoad, onFail) { ...\n",
      "function getUserDataAsync(userId) {\n    return new Promise(function(resolve, reject) {\n        // Put all your code here, this section is throw-safe.\n        getUserData(userId, resolve, reject);\n    });\n}\n"
    ],
    "comments": []
  },
  "c": {
    "params": [],
    "body": "{\n  arr.push(3);\n}",
    "snippets": [
      "function getStuff(data, callback) {\n    ...\n}\n\ngetStuff(\"dataParam\", function(err, data) {\n    if (!err) {\n\n    }\n});\n",
      "// callbacks\nvar fs = require(\"fs\");\nfs.readFile(\"name\", \"utf8\", function(err, data) {\n\n});\n",
      "var fs = Promise.promisifyAll(require(\"fs\"));\nfs.readFileAsync(\"name\", \"utf8\").then(function(data) {\n\n});\n",
      "var request = Promise.promisify(require(\"request\"));\nrequest(\"foo.bar\").then(function(result) {\n\n});\n",
      "// onload example, the promise constructor takes a\n// 'resolver' function that tells the promise when\n// to resolve and fire off its `then` handlers.\nvar loaded = new Promise(function(resolve, reject) {\n    window.addEventListener(\"load\", resolve);\n});\n\nloaded.then(function() {\n    // window is loaded here\n});\n",
      "function connect() {\n   var connection = myConnector.getConnection();  // Synchronous.\n   return new Promise(function(resolve, reject) {\n        connection.on(\"ready\", function() {\n            // When a connection has been established\n            // mark the promise as fulfilled.\n            resolve(connection);\n        });\n        connection.on(\"error\", function(e) {\n            // If it failed connecting, mark it\n            // as rejected.\n            reject(e);  // e is preferably an `Error`.\n        });\n   });\n}\n",
      "function connect() {\n   return new Promise(function(resolve, reject) {\n        // If getConnection throws here instead of getting\n        // an exception we're getting a rejection thus\n        // producing a much more consistent API.\n        var connection = myConnector.getConnection();\n        connection.on(\"ready\", function() {\n            // When a connection has been established\n            // mark the promise as fulfilled.\n            resolve(connection);\n        });\n        connection.on(\"error\", function(e) {\n            // If it failed connecting, mark it\n            // as rejected.\n            reject(e); //  e is preferably an `Error`\n        });\n   });\n}\n",
      "var Mongoose = Promise.promisifyAll(require(\"mongoose\"));\n",
      "var pg = require(\"pg\");\n// Uncomment if pg has not been properly promisified yet.\n//var Promise = require(\"bluebird\");\n//Promise.promisifyAll(pg, {\n//    filter: function(methodName) {\n//        return methodName === \"connect\"\n//    },\n//    multiArgs: true\n//});\n// Promisify rest of pg normally.\n//Promise.promisifyAll(pg);\n\nfunction getSqlConnection(connectionString) {\n    var close;\n    return pg.connectAsync(connectionString).spread(function(client, done) {\n        close = done;\n        return client;\n    }).disposer(function() {\n        if (close) close();\n    });\n}\n\nmodule.exports = getSqlConnection;\n",
      "var using = Promise.using;\n\nusing(getSqlConnection(), function(conn) {\n    // use connection here and _return the promise_\n\n}).then(function(result) {\n    // connection already disposed here\n\n});\n",
      "\nfunction withTransaction(fn) {\n  return Promise.using(pool.acquireConnection(), function(connection) {\n    var tx = connection.beginTransaction()\n    return Promise\n      .try(fn, tx)\n      .then(function(res) { return connection.commit().thenReturn(res) },\n            function(err) {\n              return connection.rollback()\n                     .catch(function(e) {/* maybe add the rollback error to err */})\n                     .thenThrow(err);\n            });\n  });\n}\nexports.withTransaction = withTransaction;\n",
      "withTransaction(tx => {\n    return tx.queryAsync(...).then(function() {\n        return tx.queryAsync(...)\n    }).then(function() {\n        return tx.queryAsync(...)\n    });\n});\n",
      "var mysql = require(\"mysql\");\n// Uncomment if mysql has not been properly promisified yet\n// var Promise = require(\"bluebird\");\n// Promise.promisifyAll(mysql);\n// Promise.promisifyAll(require(\"mysql/lib/Connection\").prototype);\n// Promise.promisifyAll(require(\"mysql/lib/Pool\").prototype);\nvar pool  = mysql.createPool({\n    connectionLimit: 10,\n    host: 'example.org',\n    user: 'bob',\n    password: 'secret'\n});\n\nfunction getSqlConnection() {\n    return pool.getConnectionAsync().disposer(function(connection) {\n        connection.release();\n    });\n}\n\nmodule.exports = getSqlConnection;\n",
      "// The most popular redis module\nvar Promise = require(\"bluebird\");\nPromise.promisifyAll(require(\"redis\"));\n",
      "// The most popular mongodb module\nvar Promise = require(\"bluebird\");\nPromise.promisifyAll(require(\"mongodb\"));\n",
      "// The most popular mysql module\nvar Promise = require(\"bluebird\");\n// Note that the library's classes are not properties of the main export\n// so we require and promisifyAll them manually\nPromise.promisifyAll(require(\"mysql/lib/Connection\").prototype);\nPromise.promisifyAll(require(\"mysql/lib/Pool\").prototype);\n",
      "// Mongoose\nvar Promise = require(\"bluebird\");\nPromise.promisifyAll(require(\"mongoose\"));\n",
      "// Request\nvar Promise = require(\"bluebird\");\nPromise.promisifyAll(require(\"request\"));\n// Use request.getAsync(...) not request(..), it will not return a promise\n",
      "// mkdir\nvar Promise = require(\"bluebird\");\nPromise.promisifyAll(require(\"mkdirp\"));\n// Use mkdirp.mkdirpAsync not mkdirp(..), it will not return a promise\n",
      "// winston\nvar Promise = require(\"bluebird\");\nPromise.promisifyAll(require(\"winston\"));\n",
      "// rimraf\nvar Promise = require(\"bluebird\");\n// The module isn't promisified but the function returned is\nvar rimrafAsync = Promise.promisify(require(\"rimraf\"));\n",
      "// xml2js\nvar Promise = require(\"bluebird\");\nPromise.promisifyAll(require(\"xml2js\"));\n",
      "// jsdom\nvar Promise = require(\"bluebird\");\nPromise.promisifyAll(require(\"jsdom\"));\n",
      "// fs-extra\nvar Promise = require(\"bluebird\");\nPromise.promisifyAll(require(\"fs-extra\"));\n",
      "// prompt\nvar Promise = require(\"bluebird\");\nPromise.promisifyAll(require(\"prompt\"));\n",
      "// Nodemailer\nvar Promise = require(\"bluebird\");\nPromise.promisifyAll(require(\"nodemailer\"));\n",
      "// ncp\nvar Promise = require(\"bluebird\");\nPromise.promisifyAll(require(\"ncp\"));\n",
      "// pg\nvar Promise = require(\"bluebird\");\nPromise.promisifyAll(require(\"pg\"));\n",
      "var ParanoidLib = require(\"...\");\nvar throwAwayInstance = ParanoidLib.createInstance();\nPromise.promisifyAll(Object.getPrototypeOf(throwAwayInstance));\n// Like before, from this point on, all new instances + even the throwAwayInstance suddenly support promises\n",
      "function getUserData(userId, onLoad, onFail) { ...\n",
      "function getUserDataAsync(userId) {\n    return new Promise(function(resolve, reject) {\n        // Put all your code here, this section is throw-safe.\n        getUserData(userId, resolve, reject);\n    });\n}\n"
    ],
    "comments": []
  },
  "f": {
    "params": [],
    "body": "{\n  var args = [].slice.call(arguments, 0, -1);\n  assert.deepEqual(args, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);\n  var cb = [].slice.call(arguments, -1)[0];\n  cb(null, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10);\n}",
    "snippets": [],
    "comments": []
  },
  "get": {
    "params": [
      "arg"
    ],
    "body": "{\n  return {\n    then: function (ful, rej) {\n      ful(arg);\n    }\n  };\n}",
    "snippets": [],
    "comments": []
  },
  "defer": {
    "params": [],
    "body": "{\n  var resolve, reject;\n  var promise = new Promise(function () {\n    resolve = arguments[0];\n    reject = arguments[1];\n  });\n  return {\n    resolve: resolve,\n    reject: reject,\n    promise: promise\n  };\n}",
    "snippets": [
      "function defer() {\n    var resolve, reject;\n    var promise = new Promise(function() {\n        resolve = arguments[0];\n        reject = arguments[1];\n    });\n    return {\n        resolve: resolve,\n        reject: reject,\n        promise: promise\n    };\n}\n"
    ],
    "comments": []
  },
  "t": {
    "params": [
      "v"
    ],
    "body": "{\n  if (called && this !== key) return;\n  called = true;\n  var b = cast(v);\n  if (b !== v || b instanceof Promise && b.isPending()) {\n    b._then(t, r, void 0, key, void 0, t);\n    return;\n  }\n  var fn = localP._fulfill;\n  if (b instanceof Promise) {\n    var fn = b.isFulfilled() ? localP._fulfill : localP._reject;\n    ASSERT(b.isResolved(), \"b.isResolved()\");\n    v = v._resolvedValue;\n    b = cast(v);\n    ASSERT(b instanceof Promise || b === v, \"b instanceof Promise || b === v\");\n    if (b !== v || b instanceof Promise && b !== v) {\n      b._then(t, r, void 0, key, void 0, t);\n      return;\n    }\n  }\n  async.invoke(fn, localP, v);\n  async.invoke(thenable.deleteCache, thenable, localX);\n}",
    "snippets": [],
    "comments": []
  },
  "r": {
    "params": [
      "v"
    ],
    "body": "{\n  if (called && this !== key) return;\n  called = true;\n  var b = cast(v);\n  if (b !== v || b instanceof Promise && b.isPending()) {\n    b._then(t, r, void 0, key, void 0, t);\n    return;\n  }\n  var fn = localP._reject;\n  if (b instanceof Promise) {\n    var fn = b.isFulfilled() ? localP._fulfill : localP._reject;\n    ASSERT(b.isResolved(), \"b.isResolved()\");\n    v = v._resolvedValue;\n    b = cast(v);\n    if (b !== v || b instanceof Promise && b.isPending()) {\n      b._then(t, r, void 0, key, void 0, t);\n      return;\n    }\n  }\n  async.invoke(fn, localP, v);\n  async.invoke(thenable.deleteCache, thenable, localX);\n}",
    "snippets": [
      "function getStuff(data, callback) {\n    ...\n}\n\ngetStuff(\"dataParam\", function(err, data) {\n    if (!err) {\n\n    }\n});\n",
      "// callbacks\nvar fs = require(\"fs\");\nfs.readFile(\"name\", \"utf8\", function(err, data) {\n\n});\n",
      "var fs = Promise.promisifyAll(require(\"fs\"));\nfs.readFileAsync(\"name\", \"utf8\").then(function(data) {\n\n});\n",
      "var request = Promise.promisify(require(\"request\"));\nrequest(\"foo.bar\").then(function(result) {\n\n});\n",
      "// onload example, the promise constructor takes a\n// 'resolver' function that tells the promise when\n// to resolve and fire off its `then` handlers.\nvar loaded = new Promise(function(resolve, reject) {\n    window.addEventListener(\"load\", resolve);\n});\n\nloaded.then(function() {\n    // window is loaded here\n});\n",
      "function connect() {\n   var connection = myConnector.getConnection();  // Synchronous.\n   return new Promise(function(resolve, reject) {\n        connection.on(\"ready\", function() {\n            // When a connection has been established\n            // mark the promise as fulfilled.\n            resolve(connection);\n        });\n        connection.on(\"error\", function(e) {\n            // If it failed connecting, mark it\n            // as rejected.\n            reject(e);  // e is preferably an `Error`.\n        });\n   });\n}\n",
      "function connect() {\n   return new Promise(function(resolve, reject) {\n        // If getConnection throws here instead of getting\n        // an exception we're getting a rejection thus\n        // producing a much more consistent API.\n        var connection = myConnector.getConnection();\n        connection.on(\"ready\", function() {\n            // When a connection has been established\n            // mark the promise as fulfilled.\n            resolve(connection);\n        });\n        connection.on(\"error\", function(e) {\n            // If it failed connecting, mark it\n            // as rejected.\n            reject(e); //  e is preferably an `Error`\n        });\n   });\n}\n",
      "var Mongoose = Promise.promisifyAll(require(\"mongoose\"));\n",
      "var pg = require(\"pg\");\n// Uncomment if pg has not been properly promisified yet.\n//var Promise = require(\"bluebird\");\n//Promise.promisifyAll(pg, {\n//    filter: function(methodName) {\n//        return methodName === \"connect\"\n//    },\n//    multiArgs: true\n//});\n// Promisify rest of pg normally.\n//Promise.promisifyAll(pg);\n\nfunction getSqlConnection(connectionString) {\n    var close;\n    return pg.connectAsync(connectionString).spread(function(client, done) {\n        close = done;\n        return client;\n    }).disposer(function() {\n        if (close) close();\n    });\n}\n\nmodule.exports = getSqlConnection;\n",
      "var using = Promise.using;\n\nusing(getSqlConnection(), function(conn) {\n    // use connection here and _return the promise_\n\n}).then(function(result) {\n    // connection already disposed here\n\n});\n",
      "\nfunction withTransaction(fn) {\n  return Promise.using(pool.acquireConnection(), function(connection) {\n    var tx = connection.beginTransaction()\n    return Promise\n      .try(fn, tx)\n      .then(function(res) { return connection.commit().thenReturn(res) },\n            function(err) {\n              return connection.rollback()\n                     .catch(function(e) {/* maybe add the rollback error to err */})\n                     .thenThrow(err);\n            });\n  });\n}\nexports.withTransaction = withTransaction;\n",
      "withTransaction(tx => {\n    return tx.queryAsync(...).then(function() {\n        return tx.queryAsync(...)\n    }).then(function() {\n        return tx.queryAsync(...)\n    });\n});\n",
      "var mysql = require(\"mysql\");\n// Uncomment if mysql has not been properly promisified yet\n// var Promise = require(\"bluebird\");\n// Promise.promisifyAll(mysql);\n// Promise.promisifyAll(require(\"mysql/lib/Connection\").prototype);\n// Promise.promisifyAll(require(\"mysql/lib/Pool\").prototype);\nvar pool  = mysql.createPool({\n    connectionLimit: 10,\n    host: 'example.org',\n    user: 'bob',\n    password: 'secret'\n});\n\nfunction getSqlConnection() {\n    return pool.getConnectionAsync().disposer(function(connection) {\n        connection.release();\n    });\n}\n\nmodule.exports = getSqlConnection;\n",
      "// The most popular redis module\nvar Promise = require(\"bluebird\");\nPromise.promisifyAll(require(\"redis\"));\n",
      "// The most popular mongodb module\nvar Promise = require(\"bluebird\");\nPromise.promisifyAll(require(\"mongodb\"));\n",
      "// The most popular mysql module\nvar Promise = require(\"bluebird\");\n// Note that the library's classes are not properties of the main export\n// so we require and promisifyAll them manually\nPromise.promisifyAll(require(\"mysql/lib/Connection\").prototype);\nPromise.promisifyAll(require(\"mysql/lib/Pool\").prototype);\n",
      "// Mongoose\nvar Promise = require(\"bluebird\");\nPromise.promisifyAll(require(\"mongoose\"));\n",
      "// Request\nvar Promise = require(\"bluebird\");\nPromise.promisifyAll(require(\"request\"));\n// Use request.getAsync(...) not request(..), it will not return a promise\n",
      "// mkdir\nvar Promise = require(\"bluebird\");\nPromise.promisifyAll(require(\"mkdirp\"));\n// Use mkdirp.mkdirpAsync not mkdirp(..), it will not return a promise\n",
      "// winston\nvar Promise = require(\"bluebird\");\nPromise.promisifyAll(require(\"winston\"));\n",
      "// rimraf\nvar Promise = require(\"bluebird\");\n// The module isn't promisified but the function returned is\nvar rimrafAsync = Promise.promisify(require(\"rimraf\"));\n",
      "// xml2js\nvar Promise = require(\"bluebird\");\nPromise.promisifyAll(require(\"xml2js\"));\n",
      "// jsdom\nvar Promise = require(\"bluebird\");\nPromise.promisifyAll(require(\"jsdom\"));\n",
      "// fs-extra\nvar Promise = require(\"bluebird\");\nPromise.promisifyAll(require(\"fs-extra\"));\n",
      "// prompt\nvar Promise = require(\"bluebird\");\nPromise.promisifyAll(require(\"prompt\"));\n",
      "// Nodemailer\nvar Promise = require(\"bluebird\");\nPromise.promisifyAll(require(\"nodemailer\"));\n",
      "// ncp\nvar Promise = require(\"bluebird\");\nPromise.promisifyAll(require(\"ncp\"));\n",
      "// pg\nvar Promise = require(\"bluebird\");\nPromise.promisifyAll(require(\"pg\"));\n",
      "var ParanoidLib = require(\"...\");\nvar throwAwayInstance = ParanoidLib.createInstance();\nPromise.promisifyAll(Object.getPrototypeOf(throwAwayInstance));\n// Like before, from this point on, all new instances + even the throwAwayInstance suddenly support promises\n",
      "function getUserData(userId, onLoad, onFail) { ...\n",
      "function getUserDataAsync(userId) {\n    return new Promise(function(resolve, reject) {\n        // Put all your code here, this section is throw-safe.\n        getUserData(userId, resolve, reject);\n    });\n}\n"
    ],
    "comments": []
  },
  "async": {
    "params": [
      "cb"
    ],
    "body": "{\n  return Promise.resolve().nodeify(cb);\n}",
    "snippets": [
      "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <title>Async Dislogs Example</title>\n  <script src=\"//cdn.jsdelivr.net/bluebird/{{ site.version }}/bluebird.js\"></script>\n  <script type=\"text/javascript\">\n    document.addEventListener('DOMContentLoaded', function() {\n      var time = document.getElementById('time-stamp');\n      clockTick();\n      setInterval(clockTick, 1000);\n      function clockTick() {\n        time.innerHTML = new Date().toLocaleTimeString();\n      }\n    });\n  </script>\n</head>\n<body>\n  <p>The current time is <span id=\"time-stamp\"></span>.</p>\n  <p>Your name is <span id=\"prompt\"></span>.</p>\n  <button id=\"action\">Set Name</button>\n</body>\n</html>\n",
      "function promptPromise(message) {\n  return new Promise(function(resolve, reject) {\n    var result = window.prompt(message);\n    if (result != null) {\n      resolve(result);\n    } else {\n      reject(new Error('User cancelled'));\n    }\n  });\n}\n\nvar button = document.getElementById('action');\nvar output = document.getElementById('prompt');\n\nbutton.addEventListener('click', function() {\n  promptPromise('What is your name?')\n    .then(function(name) {\n      output.innerHTML = String(name);\n    })\n    .catch(function() {\n      output.innerHTML = '¯\\\\_(ツ)_/¯';\n    });\n});\n",
      "<style type=\"text/css\">\n  #dialog {\n    width:      200px;\n    margin:     auto;\n    padding:    10px;\n    border:     thin solid black;\n    background: lightgreen;\n  }\n  .hidden {\n    display: none;\n  }\n</style>\n<div id=\"dialog\" class=\"hidden\">\n  <div class=\"message\">foobar</div>\n  <input type=\"text\">\n  <div>\n    <button class=\"ok\">Ok</button>\n    <button class=\"cancel\">Cancel</button>\n  </div>\n</div>\n",
      "function promptPromise(message) {\n  var dialog       = document.getElementById('dialog');\n  var input        = dialog.querySelector('input');\n  var okButton     = dialog.querySelector('button.ok');\n  var cancelButton = dialog.querySelector('button.cancel');\n\n  dialog.querySelector('.message').innerHTML = String(message);\n  dialog.className = '';\n\n  return new Promise(function(resolve, reject) {\n    dialog.addEventListener('click', function handleButtonClicks(e) {\n      if (e.target.tagName !== 'BUTTON') { return; }\n      dialog.removeEventListener('click', handleButtonClicks);\n      dialog.className = 'hidden';\n      if (e.target === okButton) {\n        resolve(input.value);\n      } else {\n        reject(new Error('User cancelled'));\n      }\n    });\n  });\n}\n",
      "return new Promise(function(resolve, reject) {\n  $('#okButton').on('click.promptDialog', function() {\n    resolve(input.value);\n  });\n  $('#cancelButton').on('click.promptDialog', reject);\n})\n.finally(function() {\n  $('#okButton').off('click.promptDialog');\n  $('#cancelButton').off('click.promptDialog');\n});\n",
      "var noop = function() {\n  return this;\n};\n\nfunction Dialog() {\n  this.setCallbacks(noop, noop);\n}\nDialog.prototype.setCallbacks = function(okCallback, cancelCallback) {\n  this._okCallback     = okCallback;\n  this._cancelCallback = cancelCallback;\n  return this;\n};\nDialog.prototype.waitForUser = function() {\n  var _this = this;\n  return new Promise(function(resolve, reject) {\n    _this.setCallbacks(resolve, reject);\n  });\n};\nDialog.prototype.show = noop;\nDialog.prototype.hide = noop;\n",
      "function PromptDialog() {\n  Dialog.call(this);\n  this.el           = document.getElementById('dialog');\n  this.inputEl      = this.el.querySelector('input');\n  this.messageEl    = this.el.querySelector('.message');\n  this.okButton     = this.el.querySelector('button.ok');\n  this.cancelButton = this.el.querySelector('button.cancel');\n  this.attachDomEvents();\n}\nPromptDialog.prototype = Object.create(Dialog.prototype);\nPromptDialog.prototype.attachDomEvents = function() {\n  var _this = this;\n  this.okButton.addEventListener('click', function() {\n    _this._okCallback(_this.inputEl.value);\n  });\n  this.cancelButton.addEventListener('click', function() {\n    _this._cancelCallback();\n  });\n};\nPromptDialog.prototype.show = function(message) {\n  this.messageEl.innerHTML = String(message);\n  this.el.className = '';\n  return this;\n};\nPromptDialog.prototype.hide = function() {\n  this.el.className = 'hidden';\n  return this;\n};\n",
      "var output = document.getElementById('prompt');\nvar prompt = new PromptDialog();\n\nprompt.show('What is your name?')\n  .waitForUser()\n  .then(function(name) {\n    output.innerHTML = String(name);\n  })\n  .catch(function() {\n    output.innerHTML = '¯\\\\_(ツ)_/¯';\n  })\n  .finally(function() {\n    prompt.hide();\n  });\n",
      "function NotifyDialog() {\n  Dialog.call(this);\n  var _this      = this;\n  this.el        = document.getElementById('notify-dialog');\n  this.messageEl = this.el.querySelector('.message');\n  this.okButton  = this.el.querySelector('button.ok');\n  this.okButton.addEventListener('click', function() {\n    _this._okCallback();\n  });\n}\nNotifyDialog.prototype = Object.create(Dialog.prototype);\nNotifyDialog.prototype.show = function(message) {\n  this.messageEl.innerHTML = String(message);\n  this.el.className = '';\n  return this;\n};\nNotifyDialog.prototype.show = function() {\n  this.el.className = 'hidden';\n  return this;\n};\n"
    ],
    "comments": []
  },
  "method": {
    "params": [],
    "body": "{}",
    "snippets": [
      "Promise.method(function(...arguments) fn) -> function\n",
      "MyClass.prototype.method = function(input) {\n    if (!this.isValid(input)) {\n        return Promise.reject(new TypeError(\"input is not valid\"));\n    }\n\n    if (this.cache(input)) {\n        return Promise.resolve(this.someCachedValue);\n    }\n\n    return db.queryAsync(input).bind(this).then(function(value) {\n        this.someCachedValue = value;\n        return value;\n    });\n};\n",
      "MyClass.prototype.method = Promise.method(function(input) {\n    if (!this.isValid(input)) {\n        throw new TypeError(\"input is not valid\");\n    }\n\n    if (this.cache(input)) {\n        return this.someCachedValue;\n    }\n\n    return db.queryAsync(input).bind(this).then(function(value) {\n        this.someCachedValue = value;\n        return value;\n    });\n});\n"
    ],
    "comments": []
  },
  "rejection": {
    "params": [],
    "body": "{\n  var error = new Error(\"test\");\n  var rejection = Promise.reject(error);\n  rejection.err = error;\n  return rejection;\n}",
    "snippets": [
      ".suppressUnhandledRejections() -> undefined\n",
      "somePromise.catch(function(){});\n",
      "var tweets = fetchTweets();\n$(document).on(\"ready\", function() {\n    tweets.then(function() {\n        // Render tweets\n    }).catch(function(e) {\n        alert(\"failed to fetch tweets because: \" + e);\n    });\n});\n",
      "var tweets = fetchTweets();\ntweets.suppressUnhandledRejections();\n$(document).on(\"ready\", function() {\n    tweets.then(function() {\n        // Render tweets\n    }).catch(function(e) {\n        alert(\"failed to fetch tweets because: \" + e);\n    });\n});\n",
      "fetchTweets()\n    .finally(function() {\n        return $.ready.promise();\n    })\n    // DOM guaranteed to be ready after this point\n    .then(function() {\n        // Render tweets\n    })\n    .catch(function(e) {\n        alert(\"failed to fetch tweets because: \" + e);\n    });\n"
    ],
    "comments": []
  },
  "Resource": {
    "params": [],
    "body": "{\n  this.isClosed = false;\n  this.closesCalled = 0;\n  this.commited = false;\n  this.rollbacked = false;\n  this.id = id++;\n}",
    "snippets": [
      "function doStuff() {\n    return Promise.all([\n        connectionPool.getConnectionAsync(),\n        fs.readFileAsync(\"file.sql\", \"utf8\")\n    ]).spread(function(connection, fileContents) {\n        return connection.query(fileContents).finally(function() {\n            connection.close();\n        });\n    }).then(function() {\n        console.log(\"query successful and connection closed\");\n    });\n}\n",
      "var using = Promise.using;\n\nusing(getConnection(),\n      fs.readFileAsync(\"file.sql\", \"utf8\"), function(connection, fileContents) {\n    return connection.query(fileContents);\n}).then(function() {\n    console.log(\"query successful and connection closed\");\n});\n"
    ],
    "comments": []
  },
  "each": {
    "params": [
      "fn"
    ],
    "body": "{\n  if (typeof fn === \"string\") {\n    var args = [].slice.call(arguments, 1);\n    return workers.forEach(function (worker) {\n      worker[fn].apply(worker, args);\n    });\n  }\n  return workers.forEach(fn);\n}",
    "snippets": [
      "Promise.each(\n    Iterable<any>|Promise<Iterable<any>> input,\n    function(any value, int index, int arrayLength) iterator\n) -> Promise<Array<any>>\n",
      "// The array to be iterated over can be a mix of values and promises.\nvar fileNames = [\"1.txt\", Promise.resolve(\"2.txt\"), \"3.txt\", Promise.delay(3000, \"4.txt\"), \"5.txt\"];\n\nPromise.each(fileNames, function(fileName, index, arrayLength) {\n    // The iteration will be performed sequentially, awaiting for any\n    // promises in the process.\n    return fs.readFileAsync(fileName).then(function(fileContents) {\n        // ...\n\n        // The final resolution value of the iterator is is irrelevant,\n        // since the result of the `Promise.each` has nothing to do with\n        // the outputs of the iterator.\n        return \"anything\"; // Doesn't matter\n    });\n}).then(function(result) {\n    // This will run after the last step is done\n    console.log(\"Done!\")\n    console.log(result); // [\"1.txt\", \"2.txt\", \"3.txt\", \"4.txt\", \"5.txt\"]\n});\n",
      "let stories = [ '8952', '8884'];\nPromise.each(stories, (item, idx, length) => {\n   return request.getAsync(`https://hacker-news.firebaseio.com/v0/item/${item}.json?print=pretty`)\n   .then(res => {\n      // need to do explicit operations here\n   })\n})\n.then(result => {\n console.log('ALL done', result);//['8952', '8884']\n})\n\n",
      "// If one of the promises in the original array rejects,\n// the iteration will stop once it reaches it\nvar items = [\"A\", Promise.delay(8000, \"B\"), Promise.reject(\"C\"), \"D\"];\n\nPromise.each(items, function(item) {\n    return Promise.delay(4000).then(function() {\n        console.log(\"On iterator: \" + item);\n    });\n}).then(function(result) {\n    // This not run\n}).catch(function(rejection) {\n    console.log(\"Catch: \" + rejection);\n});\n\n// The code above outputs the following after 12 seconds (not 16!):\n// On iterator: A\n// On iterator: B\n// Catch: C\n"
    ],
    "comments": []
  }
}