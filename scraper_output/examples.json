{
  "example": "input: {\"prompt\": {\"taskDescription\": \"Task Description: You are tasked with generating unit tests for a function called assert. The goal is to ensure that the function behaves as expected under various conditions. Write very simple unit tests that can easily pass without any need of manual correction. Include any functions that are used in the written tests and if you know the file location, the only dependency you can use is Jest and do not import any other dependencies other than the given filePath\",\"filePath\": \"test_base\\bluebird\\src\\assert.js\",\"codeContext\": {\"codeSnippet\": \"{  if (boolExpr === true) return;  if (typeof boolExpr === \\\"string\\\" && boolExpr.charAt(0) === \\\"%\\\") {    var nativeCallName = boolExpr;    var $_len = arguments.length;    var args = new Array(Math.max($_len - 2, 0));    for (var $_i = 2; $_i < $_len; ++$_i) {      args[$_i - 2] = arguments[$_i];    }    ;    if (nativeAssert(nativeCallName, args, message) === message) return;    message = nativeCallName + \\\" !== \\\" + message;  }  var ret = new AssertionError(message);  if (Error.captureStackTrace) {    Error.captureStackTrace(ret, assert);  }  throw ret;}\",\"functionDescription\": \"Parameters: boolExpr, message\",\"functionDeclaration\": \"function assert(boolExpr, message) {}\",\"DeclarationsOutsideOfFunction\": {\"0\": \"AssertionError = (function () { function AssertionError(a) { this.constructor$(a); this.message = a; this.name = \\\"AssertionError\\\"; } AssertionError.prototype = new Error(); AssertionError.prototype.constructor = AssertionError; AssertionError.prototype.constructor$ = Error; return AssertionError; })()\"}}}} output: const  assert  = require(\"../../src/assert\"); describe(\'assert function\', () => { test(\'throws AssertionError if the expression is false\', () => { expect(() => assert(false, \\\"test error\\\")).toThrow(assert.AssertionError); }); test(\'does not throw if the expression is true\', () => { expect(() => assert(true, \\\"test error\\\")).not.toThrow(); }); test(\'throws correct message with AssertionError\', () => { try { assert(false, \\\"test error\\\"); } catch (error) { expect(error.message).toBe(\\\"test error\\\"); expect(error.name).toBe(\\\"AssertionError\\\"); } }); }); describe(\'nativeAssert function\', () => { test(\'evaluates expression correctly without errors\', () => { const result = assert(\\\"%Math.max\\\", [1, 2], 2); expect(result).toBe(2); // Assuming nativeAssert is exposed for testing }); test(\'returns the expect value on SyntaxError\', () => { const result = assert(\\\"%invalidFunc\\\", [1, 2], \\\"fallback result\\\"); expect(result).toBe(\\\"fallback result\\\"); }); }); input: {\"prompt\": {\"taskDescription\": \"Task Description: You are tasked with generating unit tests for a function called map. The goal is to ensure that the function behaves as expected under various conditions. Write very simple unit tests that can easily pass without any need of manual correction. Include any functions that are used in the written tests and if you know the file location, the only dependency you can use is Jest and do not import any other dependencies other than the given filePath\",\"filePath\": \"test_base\\bluebird\\src\\map.js\",\"codeContext\": {\"codeSnippet\": \"{  if (typeof fn !== \\\"function\\\") {    return apiRejection(FUNCTION_ERROR + util.classString(fn));  }  var limit = 0;  if (options !== undefined) {    if (typeof options === \\\"object\\\" && options !== null) {      if (typeof options.concurrency !== \\\"number\\\") {        return Promise.reject(new TypeError(\\\"'concurrency' must be a number but it is \\\" + util.classString(options.concurrency)));      }      limit = options.concurrency;    } else {      return Promise.reject(new TypeError(\\\"options argument must be an object but it is \\\" + util.classString(options)));    }  }  limit = typeof limit === \\\"number\\\" && isFinite(limit) and limit >= 1 ? limit : 0;  return new MappingPromiseArray(promises, fn, limit, _filter).promise();}\",\"functionDescription\": \"Parameters: promises, fn, options, _filter\",\"functionDeclaration\": \"function map(promises, fn, options, _filter) {}\",\"DeclarationsOutsideOfFunction\": {\"0\": \"util = require(\\\"./util\\\")\",\"1\": \"limit = this._limit\",\"2\": \"promise = this._promise\"}}}} output: const Promise = require(\'bluebird\'); // Assuming Promise is exported from bluebird describe(\'map function\', () => { it(\'should map values correctly with a synchronous function\', () => { const input = [1, 2, 3]; const fn = (x) => x * 2; return expect(Promise.map(input, fn)).resolves.toEqual([2, 4, 6]); }); it(\'should map values correctly with an asynchronous function\', () => { const input = [1, 2, 3]; const fn = async (x) => x * 2; return expect(Promise.map(input, fn)).resolves.toEqual([2, 4, 6]); }); it(\'should handle errors thrown in the mapping function\', () => { const input = [1, 2, 3]; const fn = (x) => { if (x === 2) { throw new Error(\'Test error\'); } return x * 2; }; return expect(Promise.map(input, fn)).rejects.toThrow(\'Test error\'); }); it(\'should respect the concurrency option\', async () => { const input = [1, 2, 3, 4, 5]; const fn = (x) => Promise.delay(100).then(() => x * 2); const startTime = Date now; await Promise.map(input, fn, { concurrency: 2 }); the endTime = Date now; expect(endTime - startTime).toBeGreaterThanOrEqual(200); }); });"
}
