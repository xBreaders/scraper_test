{
  "node_modules\\fs-extra\\lib\\copy\\copy-sync.js": {
    "filePath": "node_modules\\fs-extra\\lib\\copy\\copy-sync.js",
    "fileContent": "'use strict'\n\nconst fs = require('graceful-fs')\nconst path = require('path')\nconst mkdirsSync = require('../mkdirs').mkdirsSync\nconst utimesMillisSync = require('../util/utimes').utimesMillisSync\nconst stat = require('../util/stat')\n\nfunction copySync (src, dest, opts) {\n  if (typeof opts === 'function') {\n    opts = { filter: opts }\n  }\n\n  opts = opts || {}\n  opts.clobber = 'clobber' in opts ? !!opts.clobber : true // default to true for now\n  opts.overwrite = 'overwrite' in opts ? !!opts.overwrite : opts.clobber // overwrite falls back to clobber\n\n  // Warn about using preserveTimestamps on 32-bit node\n  if (opts.preserveTimestamps && process.arch === 'ia32') {\n    process.emitWarning(\n      'Using the preserveTimestamps option in 32-bit node is not recommended;\\n\\n' +\n      '\\tsee https://github.com/jprichardson/node-fs-extra/issues/269',\n      'Warning', 'fs-extra-WARN0002'\n    )\n  }\n\n  const { srcStat, destStat } = stat.checkPathsSync(src, dest, 'copy', opts)\n  stat.checkParentPathsSync(src, srcStat, dest, 'copy')\n  if (opts.filter && !opts.filter(src, dest)) return\n  const destParent = path.dirname(dest)\n  if (!fs.existsSync(destParent)) mkdirsSync(destParent)\n  return getStats(destStat, src, dest, opts)\n}\n\nfunction getStats (destStat, src, dest, opts) {\n  const statSync = opts.dereference ? fs.statSync : fs.lstatSync\n  const srcStat = statSync(src)\n\n  if (srcStat.isDirectory()) return onDir(srcStat, destStat, src, dest, opts)\n  else if (srcStat.isFile() ||\n           srcStat.isCharacterDevice() ||\n           srcStat.isBlockDevice()) return onFile(srcStat, destStat, src, dest, opts)\n  else if (srcStat.isSymbolicLink()) return onLink(destStat, src, dest, opts)\n  else if (srcStat.isSocket()) throw new Error(`Cannot copy a socket file: ${src}`)\n  else if (srcStat.isFIFO()) throw new Error(`Cannot copy a FIFO pipe: ${src}`)\n  throw new Error(`Unknown file: ${src}`)\n}\n\nfunction onFile (srcStat, destStat, src, dest, opts) {\n  if (!destStat) return copyFile(srcStat, src, dest, opts)\n  return mayCopyFile(srcStat, src, dest, opts)\n}\n\nfunction mayCopyFile (srcStat, src, dest, opts) {\n  if (opts.overwrite) {\n    fs.unlinkSync(dest)\n    return copyFile(srcStat, src, dest, opts)\n  } else if (opts.errorOnExist) {\n    throw new Error(`'${dest}' already exists`)\n  }\n}\n\nfunction copyFile (srcStat, src, dest, opts) {\n  fs.copyFileSync(src, dest)\n  if (opts.preserveTimestamps) handleTimestamps(srcStat.mode, src, dest)\n  return setDestMode(dest, srcStat.mode)\n}\n\nfunction handleTimestamps (srcMode, src, dest) {\n  // Make sure the file is writable before setting the timestamp\n  // otherwise open fails with EPERM when invoked with 'r+'\n  // (through utimes call)\n  if (fileIsNotWritable(srcMode)) makeFileWritable(dest, srcMode)\n  return setDestTimestamps(src, dest)\n}\n\nfunction fileIsNotWritable (srcMode) {\n  return (srcMode & 0o200) === 0\n}\n\nfunction makeFileWritable (dest, srcMode) {\n  return setDestMode(dest, srcMode | 0o200)\n}\n\nfunction setDestMode (dest, srcMode) {\n  return fs.chmodSync(dest, srcMode)\n}\n\nfunction setDestTimestamps (src, dest) {\n  // The initial srcStat.atime cannot be trusted\n  // because it is modified by the read(2) system call\n  // (See https://nodejs.org/api/fs.html#fs_stat_time_values)\n  const updatedSrcStat = fs.statSync(src)\n  return utimesMillisSync(dest, updatedSrcStat.atime, updatedSrcStat.mtime)\n}\n\nfunction onDir (srcStat, destStat, src, dest, opts) {\n  if (!destStat) return mkDirAndCopy(srcStat.mode, src, dest, opts)\n  return copyDir(src, dest, opts)\n}\n\nfunction mkDirAndCopy (srcMode, src, dest, opts) {\n  fs.mkdirSync(dest)\n  copyDir(src, dest, opts)\n  return setDestMode(dest, srcMode)\n}\n\nfunction copyDir (src, dest, opts) {\n  fs.readdirSync(src).forEach(item => copyDirItem(item, src, dest, opts))\n}\n\nfunction copyDirItem (item, src, dest, opts) {\n  const srcItem = path.join(src, item)\n  const destItem = path.join(dest, item)\n  if (opts.filter && !opts.filter(srcItem, destItem)) return\n  const { destStat } = stat.checkPathsSync(srcItem, destItem, 'copy', opts)\n  return getStats(destStat, srcItem, destItem, opts)\n}\n\nfunction onLink (destStat, src, dest, opts) {\n  let resolvedSrc = fs.readlinkSync(src)\n  if (opts.dereference) {\n    resolvedSrc = path.resolve(process.cwd(), resolvedSrc)\n  }\n\n  if (!destStat) {\n    return fs.symlinkSync(resolvedSrc, dest)\n  } else {\n    let resolvedDest\n    try {\n      resolvedDest = fs.readlinkSync(dest)\n    } catch (err) {\n      // dest exists and is a regular file or directory,\n      // Windows may throw UNKNOWN error. If dest already exists,\n      // fs throws error anyway, so no need to guard against it here.\n      if (err.code === 'EINVAL' || err.code === 'UNKNOWN') return fs.symlinkSync(resolvedSrc, dest)\n      throw err\n    }\n    if (opts.dereference) {\n      resolvedDest = path.resolve(process.cwd(), resolvedDest)\n    }\n    if (stat.isSrcSubdir(resolvedSrc, resolvedDest)) {\n      throw new Error(`Cannot copy '${resolvedSrc}' to a subdirectory of itself, '${resolvedDest}'.`)\n    }\n\n    // prevent copy if src is a subdir of dest since unlinking\n    // dest in this case would result in removing src contents\n    // and therefore a broken symlink would be created.\n    if (stat.isSrcSubdir(resolvedDest, resolvedSrc)) {\n      throw new Error(`Cannot overwrite '${resolvedDest}' with '${resolvedSrc}'.`)\n    }\n    return copyLink(resolvedSrc, dest)\n  }\n}\n\nfunction copyLink (resolvedSrc, dest) {\n  fs.unlinkSync(dest)\n  return fs.symlinkSync(resolvedSrc, dest)\n}\n\nmodule.exports = copySync\n",
    "functions": {
      "copySync": {
        "params": [
          "src",
          "dest",
          "opts"
        ],
        "body": "{\n  if (typeof opts === 'function') {\n    opts = {\n      filter: opts\n    };\n  }\n  opts = opts || ({});\n  opts.clobber = ('clobber' in opts) ? !!opts.clobber : true;\n  opts.overwrite = ('overwrite' in opts) ? !!opts.overwrite : opts.clobber;\n  if (opts.preserveTimestamps && process.arch === 'ia32') {\n    process.emitWarning('Using the preserveTimestamps option in 32-bit node is not recommended;\\n\\n' + '\\tsee https://github.com/jprichardson/node-fs-extra/issues/269', 'Warning', 'fs-extra-WARN0002');\n  }\n  const {srcStat, destStat} = stat.checkPathsSync(src, dest, 'copy', opts);\n  stat.checkParentPathsSync(src, srcStat, dest, 'copy');\n  if (opts.filter && !opts.filter(src, dest)) return;\n  const destParent = path.dirname(dest);\n  if (!fs.existsSync(destParent)) mkdirsSync(destParent);\n  return getStats(destStat, src, dest, opts);\n}",
        "functionDeclaration": "function copySync(src, dest, opts) {}",
        "usedDeclarations": [
          "stat = require('../util/stat')",
          "path = require('path')",
          "fs = require('graceful-fs')",
          "mkdirsSync = require('../mkdirs').mkdirsSync"
        ]
      },
      "getStats": {
        "params": [
          "destStat",
          "src",
          "dest",
          "opts"
        ],
        "body": "{\n  const statSync = opts.dereference ? fs.statSync : fs.lstatSync;\n  const srcStat = statSync(src);\n  if (srcStat.isDirectory()) return onDir(srcStat, destStat, src, dest, opts); else if (srcStat.isFile() || srcStat.isCharacterDevice() || srcStat.isBlockDevice()) return onFile(srcStat, destStat, src, dest, opts); else if (srcStat.isSymbolicLink()) return onLink(destStat, src, dest, opts); else if (srcStat.isSocket()) throw new Error(`Cannot copy a socket file: ${src}`); else if (srcStat.isFIFO()) throw new Error(`Cannot copy a FIFO pipe: ${src}`);\n  throw new Error(`Unknown file: ${src}`);\n}",
        "functionDeclaration": "function getStats(destStat, src, dest, opts) {}",
        "usedDeclarations": [
          "fs = require('graceful-fs')"
        ]
      },
      "onFile": {
        "params": [
          "srcStat",
          "destStat",
          "src",
          "dest",
          "opts"
        ],
        "body": "{\n  if (!destStat) return copyFile(srcStat, src, dest, opts);\n  return mayCopyFile(srcStat, src, dest, opts);\n}",
        "functionDeclaration": "function onFile(srcStat, destStat, src, dest, opts) {}",
        "usedDeclarations": [
          "srcStat = statSync(src)"
        ]
      },
      "mayCopyFile": {
        "params": [
          "srcStat",
          "src",
          "dest",
          "opts"
        ],
        "body": "{\n  if (opts.overwrite) {\n    fs.unlinkSync(dest);\n    return copyFile(srcStat, src, dest, opts);\n  } else if (opts.errorOnExist) {\n    throw new Error(`'${dest}' already exists`);\n  }\n}",
        "functionDeclaration": "function mayCopyFile(srcStat, src, dest, opts) {}",
        "usedDeclarations": [
          "srcStat = statSync(src)",
          "fs = require('graceful-fs')"
        ]
      },
      "copyFile": {
        "params": [
          "srcStat",
          "src",
          "dest",
          "opts"
        ],
        "body": "{\n  fs.copyFileSync(src, dest);\n  if (opts.preserveTimestamps) handleTimestamps(srcStat.mode, src, dest);\n  return setDestMode(dest, srcStat.mode);\n}",
        "functionDeclaration": "function copyFile(srcStat, src, dest, opts) {}",
        "usedDeclarations": [
          "srcStat = statSync(src)",
          "fs = require('graceful-fs')"
        ]
      },
      "handleTimestamps": {
        "params": [
          "srcMode",
          "src",
          "dest"
        ],
        "body": "{\n  if (fileIsNotWritable(srcMode)) makeFileWritable(dest, srcMode);\n  return setDestTimestamps(src, dest);\n}",
        "functionDeclaration": "function handleTimestamps(srcMode, src, dest) {}",
        "usedDeclarations": []
      },
      "fileIsNotWritable": {
        "params": [
          "srcMode"
        ],
        "body": "{\n  return (srcMode & 0o200) === 0;\n}",
        "functionDeclaration": "function fileIsNotWritable(srcMode) {}",
        "usedDeclarations": []
      },
      "makeFileWritable": {
        "params": [
          "dest",
          "srcMode"
        ],
        "body": "{\n  return setDestMode(dest, srcMode | 0o200);\n}",
        "functionDeclaration": "function makeFileWritable(dest, srcMode) {}",
        "usedDeclarations": []
      },
      "setDestMode": {
        "params": [
          "dest",
          "srcMode"
        ],
        "body": "{\n  return fs.chmodSync(dest, srcMode);\n}",
        "functionDeclaration": "function setDestMode(dest, srcMode) {}",
        "usedDeclarations": [
          "fs = require('graceful-fs')"
        ]
      },
      "setDestTimestamps": {
        "params": [
          "src",
          "dest"
        ],
        "body": "{\n  const updatedSrcStat = fs.statSync(src);\n  return utimesMillisSync(dest, updatedSrcStat.atime, updatedSrcStat.mtime);\n}",
        "functionDeclaration": "function setDestTimestamps(src, dest) {}",
        "usedDeclarations": [
          "fs = require('graceful-fs')",
          "statSync = opts.dereference ? fs.statSync : fs.lstatSync",
          "utimesMillisSync = require('../util/utimes').utimesMillisSync"
        ]
      },
      "onDir": {
        "params": [
          "srcStat",
          "destStat",
          "src",
          "dest",
          "opts"
        ],
        "body": "{\n  if (!destStat) return mkDirAndCopy(srcStat.mode, src, dest, opts);\n  return copyDir(src, dest, opts);\n}",
        "functionDeclaration": "function onDir(srcStat, destStat, src, dest, opts) {}",
        "usedDeclarations": [
          "srcStat = statSync(src)"
        ]
      },
      "mkDirAndCopy": {
        "params": [
          "srcMode",
          "src",
          "dest",
          "opts"
        ],
        "body": "{\n  fs.mkdirSync(dest);\n  copyDir(src, dest, opts);\n  return setDestMode(dest, srcMode);\n}",
        "functionDeclaration": "function mkDirAndCopy(srcMode, src, dest, opts) {}",
        "usedDeclarations": [
          "fs = require('graceful-fs')"
        ]
      },
      "copyDir": {
        "params": [
          "src",
          "dest",
          "opts"
        ],
        "body": "{\n  fs.readdirSync(src).forEach(item => copyDirItem(item, src, dest, opts));\n}",
        "functionDeclaration": "function copyDir(src, dest, opts) {}",
        "usedDeclarations": [
          "fs = require('graceful-fs')"
        ]
      },
      "copyDirItem": {
        "params": [
          "item",
          "src",
          "dest",
          "opts"
        ],
        "body": "{\n  const srcItem = path.join(src, item);\n  const destItem = path.join(dest, item);\n  if (opts.filter && !opts.filter(srcItem, destItem)) return;\n  const {destStat} = stat.checkPathsSync(srcItem, destItem, 'copy', opts);\n  return getStats(destStat, srcItem, destItem, opts);\n}",
        "functionDeclaration": "function copyDirItem(item, src, dest, opts) {}",
        "usedDeclarations": [
          "path = require('path')",
          "stat = require('../util/stat')"
        ]
      },
      "onLink": {
        "params": [
          "destStat",
          "src",
          "dest",
          "opts"
        ],
        "body": "{\n  let resolvedSrc = fs.readlinkSync(src);\n  if (opts.dereference) {\n    resolvedSrc = path.resolve(process.cwd(), resolvedSrc);\n  }\n  if (!destStat) {\n    return fs.symlinkSync(resolvedSrc, dest);\n  } else {\n    let resolvedDest;\n    try {\n      resolvedDest = fs.readlinkSync(dest);\n    } catch (err) {\n      if (err.code === 'EINVAL' || err.code === 'UNKNOWN') return fs.symlinkSync(resolvedSrc, dest);\n      throw err;\n    }\n    if (opts.dereference) {\n      resolvedDest = path.resolve(process.cwd(), resolvedDest);\n    }\n    if (stat.isSrcSubdir(resolvedSrc, resolvedDest)) {\n      throw new Error(`Cannot copy '${resolvedSrc}' to a subdirectory of itself, '${resolvedDest}'.`);\n    }\n    if (stat.isSrcSubdir(resolvedDest, resolvedSrc)) {\n      throw new Error(`Cannot overwrite '${resolvedDest}' with '${resolvedSrc}'.`);\n    }\n    return copyLink(resolvedSrc, dest);\n  }\n}",
        "functionDeclaration": "function onLink(destStat, src, dest, opts) {}",
        "usedDeclarations": [
          "fs = require('graceful-fs')",
          "path = require('path')",
          "stat = require('../util/stat')"
        ]
      },
      "copyLink": {
        "params": [
          "resolvedSrc",
          "dest"
        ],
        "body": "{\n  fs.unlinkSync(dest);\n  return fs.symlinkSync(resolvedSrc, dest);\n}",
        "functionDeclaration": "function copyLink(resolvedSrc, dest) {}",
        "usedDeclarations": [
          "resolvedSrc = fs.readlinkSync(src)",
          "fs = require('graceful-fs')"
        ]
      }
    }
  },
  "node_modules\\fs-extra\\lib\\copy\\copy.js": {
    "filePath": "node_modules\\fs-extra\\lib\\copy\\copy.js",
    "fileContent": "'use strict'\n\nconst fs = require('../fs')\nconst path = require('path')\nconst { mkdirs } = require('../mkdirs')\nconst { pathExists } = require('../path-exists')\nconst { utimesMillis } = require('../util/utimes')\nconst stat = require('../util/stat')\n\nasync function copy (src, dest, opts = {}) {\n  if (typeof opts === 'function') {\n    opts = { filter: opts }\n  }\n\n  opts.clobber = 'clobber' in opts ? !!opts.clobber : true // default to true for now\n  opts.overwrite = 'overwrite' in opts ? !!opts.overwrite : opts.clobber // overwrite falls back to clobber\n\n  // Warn about using preserveTimestamps on 32-bit node\n  if (opts.preserveTimestamps && process.arch === 'ia32') {\n    process.emitWarning(\n      'Using the preserveTimestamps option in 32-bit node is not recommended;\\n\\n' +\n      '\\tsee https://github.com/jprichardson/node-fs-extra/issues/269',\n      'Warning', 'fs-extra-WARN0001'\n    )\n  }\n\n  const { srcStat, destStat } = await stat.checkPaths(src, dest, 'copy', opts)\n\n  await stat.checkParentPaths(src, srcStat, dest, 'copy')\n\n  const include = await runFilter(src, dest, opts)\n\n  if (!include) return\n\n  // check if the parent of dest exists, and create it if it doesn't exist\n  const destParent = path.dirname(dest)\n  const dirExists = await pathExists(destParent)\n  if (!dirExists) {\n    await mkdirs(destParent)\n  }\n\n  await getStatsAndPerformCopy(destStat, src, dest, opts)\n}\n\nasync function runFilter (src, dest, opts) {\n  if (!opts.filter) return true\n  return opts.filter(src, dest)\n}\n\nasync function getStatsAndPerformCopy (destStat, src, dest, opts) {\n  const statFn = opts.dereference ? fs.stat : fs.lstat\n  const srcStat = await statFn(src)\n\n  if (srcStat.isDirectory()) return onDir(srcStat, destStat, src, dest, opts)\n\n  if (\n    srcStat.isFile() ||\n    srcStat.isCharacterDevice() ||\n    srcStat.isBlockDevice()\n  ) return onFile(srcStat, destStat, src, dest, opts)\n\n  if (srcStat.isSymbolicLink()) return onLink(destStat, src, dest, opts)\n  if (srcStat.isSocket()) throw new Error(`Cannot copy a socket file: ${src}`)\n  if (srcStat.isFIFO()) throw new Error(`Cannot copy a FIFO pipe: ${src}`)\n  throw new Error(`Unknown file: ${src}`)\n}\n\nasync function onFile (srcStat, destStat, src, dest, opts) {\n  if (!destStat) return copyFile(srcStat, src, dest, opts)\n\n  if (opts.overwrite) {\n    await fs.unlink(dest)\n    return copyFile(srcStat, src, dest, opts)\n  }\n  if (opts.errorOnExist) {\n    throw new Error(`'${dest}' already exists`)\n  }\n}\n\nasync function copyFile (srcStat, src, dest, opts) {\n  await fs.copyFile(src, dest)\n  if (opts.preserveTimestamps) {\n    // Make sure the file is writable before setting the timestamp\n    // otherwise open fails with EPERM when invoked with 'r+'\n    // (through utimes call)\n    if (fileIsNotWritable(srcStat.mode)) {\n      await makeFileWritable(dest, srcStat.mode)\n    }\n\n    // Set timestamps and mode correspondingly\n\n    // Note that The initial srcStat.atime cannot be trusted\n    // because it is modified by the read(2) system call\n    // (See https://nodejs.org/api/fs.html#fs_stat_time_values)\n    const updatedSrcStat = await fs.stat(src)\n    await utimesMillis(dest, updatedSrcStat.atime, updatedSrcStat.mtime)\n  }\n\n  return fs.chmod(dest, srcStat.mode)\n}\n\nfunction fileIsNotWritable (srcMode) {\n  return (srcMode & 0o200) === 0\n}\n\nfunction makeFileWritable (dest, srcMode) {\n  return fs.chmod(dest, srcMode | 0o200)\n}\n\nasync function onDir (srcStat, destStat, src, dest, opts) {\n  // the dest directory might not exist, create it\n  if (!destStat) {\n    await fs.mkdir(dest)\n  }\n\n  const items = await fs.readdir(src)\n\n  // loop through the files in the current directory to copy everything\n  await Promise.all(items.map(async item => {\n    const srcItem = path.join(src, item)\n    const destItem = path.join(dest, item)\n\n    // skip the item if it is matches by the filter function\n    const include = await runFilter(srcItem, destItem, opts)\n    if (!include) return\n\n    const { destStat } = await stat.checkPaths(srcItem, destItem, 'copy', opts)\n\n    // If the item is a copyable file, `getStatsAndPerformCopy` will copy it\n    // If the item is a directory, `getStatsAndPerformCopy` will call `onDir` recursively\n    return getStatsAndPerformCopy(destStat, srcItem, destItem, opts)\n  }))\n\n  if (!destStat) {\n    await fs.chmod(dest, srcStat.mode)\n  }\n}\n\nasync function onLink (destStat, src, dest, opts) {\n  let resolvedSrc = await fs.readlink(src)\n  if (opts.dereference) {\n    resolvedSrc = path.resolve(process.cwd(), resolvedSrc)\n  }\n  if (!destStat) {\n    return fs.symlink(resolvedSrc, dest)\n  }\n\n  let resolvedDest = null\n  try {\n    resolvedDest = await fs.readlink(dest)\n  } catch (e) {\n    // dest exists and is a regular file or directory,\n    // Windows may throw UNKNOWN error. If dest already exists,\n    // fs throws error anyway, so no need to guard against it here.\n    if (e.code === 'EINVAL' || e.code === 'UNKNOWN') return fs.symlink(resolvedSrc, dest)\n    throw e\n  }\n  if (opts.dereference) {\n    resolvedDest = path.resolve(process.cwd(), resolvedDest)\n  }\n  if (stat.isSrcSubdir(resolvedSrc, resolvedDest)) {\n    throw new Error(`Cannot copy '${resolvedSrc}' to a subdirectory of itself, '${resolvedDest}'.`)\n  }\n\n  // do not copy if src is a subdir of dest since unlinking\n  // dest in this case would result in removing src contents\n  // and therefore a broken symlink would be created.\n  if (stat.isSrcSubdir(resolvedDest, resolvedSrc)) {\n    throw new Error(`Cannot overwrite '${resolvedDest}' with '${resolvedSrc}'.`)\n  }\n\n  // copy the link\n  await fs.unlink(dest)\n  return fs.symlink(resolvedSrc, dest)\n}\n\nmodule.exports = copy\n",
    "functions": {
      "copy": {
        "params": [
          "src",
          "dest",
          null
        ],
        "body": "{\n  if (typeof opts === 'function') {\n    opts = {\n      filter: opts\n    };\n  }\n  opts.clobber = ('clobber' in opts) ? !!opts.clobber : true;\n  opts.overwrite = ('overwrite' in opts) ? !!opts.overwrite : opts.clobber;\n  if (opts.preserveTimestamps && process.arch === 'ia32') {\n    process.emitWarning('Using the preserveTimestamps option in 32-bit node is not recommended;\\n\\n' + '\\tsee https://github.com/jprichardson/node-fs-extra/issues/269', 'Warning', 'fs-extra-WARN0001');\n  }\n  const {srcStat, destStat} = await stat.checkPaths(src, dest, 'copy', opts);\n  await stat.checkParentPaths(src, srcStat, dest, 'copy');\n  const include = await runFilter(src, dest, opts);\n  if (!include) return;\n  const destParent = path.dirname(dest);\n  const dirExists = await pathExists(destParent);\n  if (!dirExists) {\n    await mkdirs(destParent);\n  }\n  await getStatsAndPerformCopy(destStat, src, dest, opts);\n}",
        "functionDeclaration": "function copy(src, dest, opts = {}) {}",
        "usedDeclarations": [
          "stat = require('../util/stat')",
          "path = require('path')"
        ]
      },
      "runFilter": {
        "params": [
          "src",
          "dest",
          "opts"
        ],
        "body": "{\n  if (!opts.filter) return true;\n  return opts.filter(src, dest);\n}",
        "functionDeclaration": "function runFilter(src, dest, opts) {}",
        "usedDeclarations": []
      },
      "getStatsAndPerformCopy": {
        "params": [
          "destStat",
          "src",
          "dest",
          "opts"
        ],
        "body": "{\n  const statFn = opts.dereference ? fs.stat : fs.lstat;\n  const srcStat = await statFn(src);\n  if (srcStat.isDirectory()) return onDir(srcStat, destStat, src, dest, opts);\n  if (srcStat.isFile() || srcStat.isCharacterDevice() || srcStat.isBlockDevice()) return onFile(srcStat, destStat, src, dest, opts);\n  if (srcStat.isSymbolicLink()) return onLink(destStat, src, dest, opts);\n  if (srcStat.isSocket()) throw new Error(`Cannot copy a socket file: ${src}`);\n  if (srcStat.isFIFO()) throw new Error(`Cannot copy a FIFO pipe: ${src}`);\n  throw new Error(`Unknown file: ${src}`);\n}",
        "functionDeclaration": "function getStatsAndPerformCopy(destStat, src, dest, opts) {}",
        "usedDeclarations": [
          "fs = require('../fs')",
          "stat = require('../util/stat')"
        ]
      },
      "onFile": {
        "params": [
          "srcStat",
          "destStat",
          "src",
          "dest",
          "opts"
        ],
        "body": "{\n  if (!destStat) return copyFile(srcStat, src, dest, opts);\n  if (opts.overwrite) {\n    await fs.unlink(dest);\n    return copyFile(srcStat, src, dest, opts);\n  }\n  if (opts.errorOnExist) {\n    throw new Error(`'${dest}' already exists`);\n  }\n}",
        "functionDeclaration": "function onFile(srcStat, destStat, src, dest, opts) {}",
        "usedDeclarations": [
          "srcStat = await statFn(src)",
          "fs = require('../fs')"
        ]
      },
      "copyFile": {
        "params": [
          "srcStat",
          "src",
          "dest",
          "opts"
        ],
        "body": "{\n  await fs.copyFile(src, dest);\n  if (opts.preserveTimestamps) {\n    if (fileIsNotWritable(srcStat.mode)) {\n      await makeFileWritable(dest, srcStat.mode);\n    }\n    const updatedSrcStat = await fs.stat(src);\n    await utimesMillis(dest, updatedSrcStat.atime, updatedSrcStat.mtime);\n  }\n  return fs.chmod(dest, srcStat.mode);\n}",
        "functionDeclaration": "function copyFile(srcStat, src, dest, opts) {}",
        "usedDeclarations": [
          "srcStat = await statFn(src)",
          "fs = require('../fs')",
          "stat = require('../util/stat')"
        ]
      },
      "fileIsNotWritable": {
        "params": [
          "srcMode"
        ],
        "body": "{\n  return (srcMode & 0o200) === 0;\n}",
        "functionDeclaration": "function fileIsNotWritable(srcMode) {}",
        "usedDeclarations": []
      },
      "makeFileWritable": {
        "params": [
          "dest",
          "srcMode"
        ],
        "body": "{\n  return fs.chmod(dest, srcMode | 0o200);\n}",
        "functionDeclaration": "function makeFileWritable(dest, srcMode) {}",
        "usedDeclarations": [
          "fs = require('../fs')"
        ]
      },
      "onDir": {
        "params": [
          "srcStat",
          "destStat",
          "src",
          "dest",
          "opts"
        ],
        "body": "{\n  if (!destStat) {\n    await fs.mkdir(dest);\n  }\n  const items = await fs.readdir(src);\n  await Promise.all(items.map(async item => {\n    const srcItem = path.join(src, item);\n    const destItem = path.join(dest, item);\n    const include = await runFilter(srcItem, destItem, opts);\n    if (!include) return;\n    const {destStat} = await stat.checkPaths(srcItem, destItem, 'copy', opts);\n    return getStatsAndPerformCopy(destStat, srcItem, destItem, opts);\n  }));\n  if (!destStat) {\n    await fs.chmod(dest, srcStat.mode);\n  }\n}",
        "functionDeclaration": "function onDir(srcStat, destStat, src, dest, opts) {}",
        "usedDeclarations": [
          "srcStat = await statFn(src)",
          "fs = require('../fs')",
          "path = require('path')",
          "include = await runFilter(src, dest, opts)",
          "stat = require('../util/stat')"
        ]
      },
      "onLink": {
        "params": [
          "destStat",
          "src",
          "dest",
          "opts"
        ],
        "body": "{\n  let resolvedSrc = await fs.readlink(src);\n  if (opts.dereference) {\n    resolvedSrc = path.resolve(process.cwd(), resolvedSrc);\n  }\n  if (!destStat) {\n    return fs.symlink(resolvedSrc, dest);\n  }\n  let resolvedDest = null;\n  try {\n    resolvedDest = await fs.readlink(dest);\n  } catch (e) {\n    if (e.code === 'EINVAL' || e.code === 'UNKNOWN') return fs.symlink(resolvedSrc, dest);\n    throw e;\n  }\n  if (opts.dereference) {\n    resolvedDest = path.resolve(process.cwd(), resolvedDest);\n  }\n  if (stat.isSrcSubdir(resolvedSrc, resolvedDest)) {\n    throw new Error(`Cannot copy '${resolvedSrc}' to a subdirectory of itself, '${resolvedDest}'.`);\n  }\n  if (stat.isSrcSubdir(resolvedDest, resolvedSrc)) {\n    throw new Error(`Cannot overwrite '${resolvedDest}' with '${resolvedSrc}'.`);\n  }\n  await fs.unlink(dest);\n  return fs.symlink(resolvedSrc, dest);\n}",
        "functionDeclaration": "function onLink(destStat, src, dest, opts) {}",
        "usedDeclarations": [
          "fs = require('../fs')",
          "path = require('path')",
          "stat = require('../util/stat')"
        ]
      }
    }
  },
  "node_modules\\fs-extra\\lib\\copy\\index.js": {
    "filePath": "node_modules\\fs-extra\\lib\\copy\\index.js",
    "fileContent": "'use strict'\n\nconst u = require('universalify').fromPromise\nmodule.exports = {\n  copy: u(require('./copy')),\n  copySync: require('./copy-sync')\n}\n",
    "functions": {}
  },
  "node_modules\\fs-extra\\lib\\empty\\index.js": {
    "filePath": "node_modules\\fs-extra\\lib\\empty\\index.js",
    "fileContent": "'use strict'\n\nconst u = require('universalify').fromPromise\nconst fs = require('../fs')\nconst path = require('path')\nconst mkdir = require('../mkdirs')\nconst remove = require('../remove')\n\nconst emptyDir = u(async function emptyDir (dir) {\n  let items\n  try {\n    items = await fs.readdir(dir)\n  } catch {\n    return mkdir.mkdirs(dir)\n  }\n\n  return Promise.all(items.map(item => remove.remove(path.join(dir, item))))\n})\n\nfunction emptyDirSync (dir) {\n  let items\n  try {\n    items = fs.readdirSync(dir)\n  } catch {\n    return mkdir.mkdirsSync(dir)\n  }\n\n  items.forEach(item => {\n    item = path.join(dir, item)\n    remove.removeSync(item)\n  })\n}\n\nmodule.exports = {\n  emptyDirSync,\n  emptydirSync: emptyDirSync,\n  emptyDir,\n  emptydir: emptyDir\n}\n",
    "functions": {
      "emptyDir": {
        "params": [
          "dir"
        ],
        "body": "{\n  let items;\n  try {\n    items = await fs.readdir(dir);\n  } catch {\n    return mkdir.mkdirs(dir);\n  }\n  return Promise.all(items.map(item => remove.remove(path.join(dir, item))));\n}",
        "functionDeclaration": "function emptyDir(dir) {}",
        "usedDeclarations": [
          "emptyDir = u(async function emptyDir(dir) {\n  let items;\n  try {\n    items = await fs.readdir(dir);\n  } catch {\n    return mkdir.mkdirs(dir);\n  }\n  return Promise.all(items.map(item => remove.remove(path.join(dir, item))));\n})",
          "fs = require('../fs')",
          "mkdir = require('../mkdirs')",
          "remove = require('../remove')",
          "path = require('path')"
        ]
      },
      "emptyDirSync": {
        "params": [
          "dir"
        ],
        "body": "{\n  let items;\n  try {\n    items = fs.readdirSync(dir);\n  } catch {\n    return mkdir.mkdirsSync(dir);\n  }\n  items.forEach(item => {\n    item = path.join(dir, item);\n    remove.removeSync(item);\n  });\n}",
        "functionDeclaration": "function emptyDirSync(dir) {}",
        "usedDeclarations": [
          "items",
          "fs = require('../fs')",
          "mkdir = require('../mkdirs')",
          "path = require('path')",
          "remove = require('../remove')"
        ]
      }
    }
  },
  "node_modules\\fs-extra\\lib\\ensure\\file.js": {
    "filePath": "node_modules\\fs-extra\\lib\\ensure\\file.js",
    "fileContent": "'use strict'\n\nconst u = require('universalify').fromPromise\nconst path = require('path')\nconst fs = require('../fs')\nconst mkdir = require('../mkdirs')\n\nasync function createFile (file) {\n  let stats\n  try {\n    stats = await fs.stat(file)\n  } catch { }\n  if (stats && stats.isFile()) return\n\n  const dir = path.dirname(file)\n\n  let dirStats = null\n  try {\n    dirStats = await fs.stat(dir)\n  } catch (err) {\n    // if the directory doesn't exist, make it\n    if (err.code === 'ENOENT') {\n      await mkdir.mkdirs(dir)\n      await fs.writeFile(file, '')\n      return\n    } else {\n      throw err\n    }\n  }\n\n  if (dirStats.isDirectory()) {\n    await fs.writeFile(file, '')\n  } else {\n    // parent is not a directory\n    // This is just to cause an internal ENOTDIR error to be thrown\n    await fs.readdir(dir)\n  }\n}\n\nfunction createFileSync (file) {\n  let stats\n  try {\n    stats = fs.statSync(file)\n  } catch { }\n  if (stats && stats.isFile()) return\n\n  const dir = path.dirname(file)\n  try {\n    if (!fs.statSync(dir).isDirectory()) {\n      // parent is not a directory\n      // This is just to cause an internal ENOTDIR error to be thrown\n      fs.readdirSync(dir)\n    }\n  } catch (err) {\n    // If the stat call above failed because the directory doesn't exist, create it\n    if (err && err.code === 'ENOENT') mkdir.mkdirsSync(dir)\n    else throw err\n  }\n\n  fs.writeFileSync(file, '')\n}\n\nmodule.exports = {\n  createFile: u(createFile),\n  createFileSync\n}\n",
    "functions": {
      "createFile": {
        "params": [
          "file"
        ],
        "body": "{\n  let stats;\n  try {\n    stats = await fs.stat(file);\n  } catch {}\n  if (stats && stats.isFile()) return;\n  const dir = path.dirname(file);\n  let dirStats = null;\n  try {\n    dirStats = await fs.stat(dir);\n  } catch (err) {\n    if (err.code === 'ENOENT') {\n      await mkdir.mkdirs(dir);\n      await fs.writeFile(file, '');\n      return;\n    } else {\n      throw err;\n    }\n  }\n  if (dirStats.isDirectory()) {\n    await fs.writeFile(file, '');\n  } else {\n    await fs.readdir(dir);\n  }\n}",
        "functionDeclaration": "function createFile(file) {}",
        "usedDeclarations": [
          "fs = require('../fs')",
          "path = require('path')",
          "mkdir = require('../mkdirs')"
        ]
      },
      "createFileSync": {
        "params": [
          "file"
        ],
        "body": "{\n  let stats;\n  try {\n    stats = fs.statSync(file);\n  } catch {}\n  if (stats && stats.isFile()) return;\n  const dir = path.dirname(file);\n  try {\n    if (!fs.statSync(dir).isDirectory()) {\n      fs.readdirSync(dir);\n    }\n  } catch (err) {\n    if (err && err.code === 'ENOENT') mkdir.mkdirsSync(dir); else throw err;\n  }\n  fs.writeFileSync(file, '');\n}",
        "functionDeclaration": "function createFileSync(file) {}",
        "usedDeclarations": [
          "stats",
          "fs = require('../fs')",
          "dir = path.dirname(file)",
          "path = require('path')",
          "mkdir = require('../mkdirs')"
        ]
      }
    }
  },
  "node_modules\\fs-extra\\lib\\ensure\\index.js": {
    "filePath": "node_modules\\fs-extra\\lib\\ensure\\index.js",
    "fileContent": "'use strict'\n\nconst { createFile, createFileSync } = require('./file')\nconst { createLink, createLinkSync } = require('./link')\nconst { createSymlink, createSymlinkSync } = require('./symlink')\n\nmodule.exports = {\n  // file\n  createFile,\n  createFileSync,\n  ensureFile: createFile,\n  ensureFileSync: createFileSync,\n  // link\n  createLink,\n  createLinkSync,\n  ensureLink: createLink,\n  ensureLinkSync: createLinkSync,\n  // symlink\n  createSymlink,\n  createSymlinkSync,\n  ensureSymlink: createSymlink,\n  ensureSymlinkSync: createSymlinkSync\n}\n",
    "functions": {}
  },
  "node_modules\\fs-extra\\lib\\ensure\\link.js": {
    "filePath": "node_modules\\fs-extra\\lib\\ensure\\link.js",
    "fileContent": "'use strict'\n\nconst u = require('universalify').fromPromise\nconst path = require('path')\nconst fs = require('../fs')\nconst mkdir = require('../mkdirs')\nconst { pathExists } = require('../path-exists')\nconst { areIdentical } = require('../util/stat')\n\nasync function createLink (srcpath, dstpath) {\n  let dstStat\n  try {\n    dstStat = await fs.lstat(dstpath)\n  } catch {\n    // ignore error\n  }\n\n  let srcStat\n  try {\n    srcStat = await fs.lstat(srcpath)\n  } catch (err) {\n    err.message = err.message.replace('lstat', 'ensureLink')\n    throw err\n  }\n\n  if (dstStat && areIdentical(srcStat, dstStat)) return\n\n  const dir = path.dirname(dstpath)\n\n  const dirExists = await pathExists(dir)\n\n  if (!dirExists) {\n    await mkdir.mkdirs(dir)\n  }\n\n  await fs.link(srcpath, dstpath)\n}\n\nfunction createLinkSync (srcpath, dstpath) {\n  let dstStat\n  try {\n    dstStat = fs.lstatSync(dstpath)\n  } catch {}\n\n  try {\n    const srcStat = fs.lstatSync(srcpath)\n    if (dstStat && areIdentical(srcStat, dstStat)) return\n  } catch (err) {\n    err.message = err.message.replace('lstat', 'ensureLink')\n    throw err\n  }\n\n  const dir = path.dirname(dstpath)\n  const dirExists = fs.existsSync(dir)\n  if (dirExists) return fs.linkSync(srcpath, dstpath)\n  mkdir.mkdirsSync(dir)\n\n  return fs.linkSync(srcpath, dstpath)\n}\n\nmodule.exports = {\n  createLink: u(createLink),\n  createLinkSync\n}\n",
    "functions": {
      "createLink": {
        "params": [
          "srcpath",
          "dstpath"
        ],
        "body": "{\n  let dstStat;\n  try {\n    dstStat = await fs.lstat(dstpath);\n  } catch {}\n  let srcStat;\n  try {\n    srcStat = await fs.lstat(srcpath);\n  } catch (err) {\n    err.message = err.message.replace('lstat', 'ensureLink');\n    throw err;\n  }\n  if (dstStat && areIdentical(srcStat, dstStat)) return;\n  const dir = path.dirname(dstpath);\n  const dirExists = await pathExists(dir);\n  if (!dirExists) {\n    await mkdir.mkdirs(dir);\n  }\n  await fs.link(srcpath, dstpath);\n}",
        "functionDeclaration": "function createLink(srcpath, dstpath) {}",
        "usedDeclarations": [
          "fs = require('../fs')",
          "path = require('path')",
          "mkdir = require('../mkdirs')"
        ]
      },
      "createLinkSync": {
        "params": [
          "srcpath",
          "dstpath"
        ],
        "body": "{\n  let dstStat;\n  try {\n    dstStat = fs.lstatSync(dstpath);\n  } catch {}\n  try {\n    const srcStat = fs.lstatSync(srcpath);\n    if (dstStat && areIdentical(srcStat, dstStat)) return;\n  } catch (err) {\n    err.message = err.message.replace('lstat', 'ensureLink');\n    throw err;\n  }\n  const dir = path.dirname(dstpath);\n  const dirExists = fs.existsSync(dir);\n  if (dirExists) return fs.linkSync(srcpath, dstpath);\n  mkdir.mkdirsSync(dir);\n  return fs.linkSync(srcpath, dstpath);\n}",
        "functionDeclaration": "function createLinkSync(srcpath, dstpath) {}",
        "usedDeclarations": [
          "dstStat",
          "fs = require('../fs')",
          "srcStat",
          "dir = path.dirname(dstpath)",
          "path = require('path')",
          "dirExists = await pathExists(dir)",
          "mkdir = require('../mkdirs')"
        ]
      }
    }
  },
  "node_modules\\fs-extra\\lib\\ensure\\symlink-paths.js": {
    "filePath": "node_modules\\fs-extra\\lib\\ensure\\symlink-paths.js",
    "fileContent": "'use strict'\n\nconst path = require('path')\nconst fs = require('../fs')\nconst { pathExists } = require('../path-exists')\n\nconst u = require('universalify').fromPromise\n\n/**\n * Function that returns two types of paths, one relative to symlink, and one\n * relative to the current working directory. Checks if path is absolute or\n * relative. If the path is relative, this function checks if the path is\n * relative to symlink or relative to current working directory. This is an\n * initiative to find a smarter `srcpath` to supply when building symlinks.\n * This allows you to determine which path to use out of one of three possible\n * types of source paths. The first is an absolute path. This is detected by\n * `path.isAbsolute()`. When an absolute path is provided, it is checked to\n * see if it exists. If it does it's used, if not an error is returned\n * (callback)/ thrown (sync). The other two options for `srcpath` are a\n * relative url. By default Node's `fs.symlink` works by creating a symlink\n * using `dstpath` and expects the `srcpath` to be relative to the newly\n * created symlink. If you provide a `srcpath` that does not exist on the file\n * system it results in a broken symlink. To minimize this, the function\n * checks to see if the 'relative to symlink' source file exists, and if it\n * does it will use it. If it does not, it checks if there's a file that\n * exists that is relative to the current working directory, if does its used.\n * This preserves the expectations of the original fs.symlink spec and adds\n * the ability to pass in `relative to current working direcotry` paths.\n */\n\nasync function symlinkPaths (srcpath, dstpath) {\n  if (path.isAbsolute(srcpath)) {\n    try {\n      await fs.lstat(srcpath)\n    } catch (err) {\n      err.message = err.message.replace('lstat', 'ensureSymlink')\n      throw err\n    }\n\n    return {\n      toCwd: srcpath,\n      toDst: srcpath\n    }\n  }\n\n  const dstdir = path.dirname(dstpath)\n  const relativeToDst = path.join(dstdir, srcpath)\n\n  const exists = await pathExists(relativeToDst)\n  if (exists) {\n    return {\n      toCwd: relativeToDst,\n      toDst: srcpath\n    }\n  }\n\n  try {\n    await fs.lstat(srcpath)\n  } catch (err) {\n    err.message = err.message.replace('lstat', 'ensureSymlink')\n    throw err\n  }\n\n  return {\n    toCwd: srcpath,\n    toDst: path.relative(dstdir, srcpath)\n  }\n}\n\nfunction symlinkPathsSync (srcpath, dstpath) {\n  if (path.isAbsolute(srcpath)) {\n    const exists = fs.existsSync(srcpath)\n    if (!exists) throw new Error('absolute srcpath does not exist')\n    return {\n      toCwd: srcpath,\n      toDst: srcpath\n    }\n  }\n\n  const dstdir = path.dirname(dstpath)\n  const relativeToDst = path.join(dstdir, srcpath)\n  const exists = fs.existsSync(relativeToDst)\n  if (exists) {\n    return {\n      toCwd: relativeToDst,\n      toDst: srcpath\n    }\n  }\n\n  const srcExists = fs.existsSync(srcpath)\n  if (!srcExists) throw new Error('relative srcpath does not exist')\n  return {\n    toCwd: srcpath,\n    toDst: path.relative(dstdir, srcpath)\n  }\n}\n\nmodule.exports = {\n  symlinkPaths: u(symlinkPaths),\n  symlinkPathsSync\n}\n",
    "functions": {
      "symlinkPaths": {
        "params": [
          "srcpath",
          "dstpath"
        ],
        "body": "{\n  if (path.isAbsolute(srcpath)) {\n    try {\n      await fs.lstat(srcpath);\n    } catch (err) {\n      err.message = err.message.replace('lstat', 'ensureSymlink');\n      throw err;\n    }\n    return {\n      toCwd: srcpath,\n      toDst: srcpath\n    };\n  }\n  const dstdir = path.dirname(dstpath);\n  const relativeToDst = path.join(dstdir, srcpath);\n  const exists = await pathExists(relativeToDst);\n  if (exists) {\n    return {\n      toCwd: relativeToDst,\n      toDst: srcpath\n    };\n  }\n  try {\n    await fs.lstat(srcpath);\n  } catch (err) {\n    err.message = err.message.replace('lstat', 'ensureSymlink');\n    throw err;\n  }\n  return {\n    toCwd: srcpath,\n    toDst: path.relative(dstdir, srcpath)\n  };\n}",
        "functionDeclaration": "function symlinkPaths(srcpath, dstpath) {}",
        "usedDeclarations": [
          "path = require('path')",
          "fs = require('../fs')"
        ]
      },
      "symlinkPathsSync": {
        "params": [
          "srcpath",
          "dstpath"
        ],
        "body": "{\n  if (path.isAbsolute(srcpath)) {\n    const exists = fs.existsSync(srcpath);\n    if (!exists) throw new Error('absolute srcpath does not exist');\n    return {\n      toCwd: srcpath,\n      toDst: srcpath\n    };\n  }\n  const dstdir = path.dirname(dstpath);\n  const relativeToDst = path.join(dstdir, srcpath);\n  const exists = fs.existsSync(relativeToDst);\n  if (exists) {\n    return {\n      toCwd: relativeToDst,\n      toDst: srcpath\n    };\n  }\n  const srcExists = fs.existsSync(srcpath);\n  if (!srcExists) throw new Error('relative srcpath does not exist');\n  return {\n    toCwd: srcpath,\n    toDst: path.relative(dstdir, srcpath)\n  };\n}",
        "functionDeclaration": "function symlinkPathsSync(srcpath, dstpath) {}",
        "usedDeclarations": [
          "path = require('path')",
          "exists = await pathExists(relativeToDst)",
          "fs = require('../fs')",
          "dstdir = path.dirname(dstpath)",
          "relativeToDst = path.join(dstdir, srcpath)"
        ]
      }
    }
  },
  "node_modules\\fs-extra\\lib\\ensure\\symlink-type.js": {
    "filePath": "node_modules\\fs-extra\\lib\\ensure\\symlink-type.js",
    "fileContent": "'use strict'\n\nconst fs = require('../fs')\nconst u = require('universalify').fromPromise\n\nasync function symlinkType (srcpath, type) {\n  if (type) return type\n\n  let stats\n  try {\n    stats = await fs.lstat(srcpath)\n  } catch {\n    return 'file'\n  }\n\n  return (stats && stats.isDirectory()) ? 'dir' : 'file'\n}\n\nfunction symlinkTypeSync (srcpath, type) {\n  if (type) return type\n\n  let stats\n  try {\n    stats = fs.lstatSync(srcpath)\n  } catch {\n    return 'file'\n  }\n  return (stats && stats.isDirectory()) ? 'dir' : 'file'\n}\n\nmodule.exports = {\n  symlinkType: u(symlinkType),\n  symlinkTypeSync\n}\n",
    "functions": {
      "symlinkType": {
        "params": [
          "srcpath",
          "type"
        ],
        "body": "{\n  if (type) return type;\n  let stats;\n  try {\n    stats = await fs.lstat(srcpath);\n  } catch {\n    return 'file';\n  }\n  return stats && stats.isDirectory() ? 'dir' : 'file';\n}",
        "functionDeclaration": "function symlinkType(srcpath, type) {}",
        "usedDeclarations": [
          "fs = require('../fs')"
        ]
      },
      "symlinkTypeSync": {
        "params": [
          "srcpath",
          "type"
        ],
        "body": "{\n  if (type) return type;\n  let stats;\n  try {\n    stats = fs.lstatSync(srcpath);\n  } catch {\n    return 'file';\n  }\n  return stats && stats.isDirectory() ? 'dir' : 'file';\n}",
        "functionDeclaration": "function symlinkTypeSync(srcpath, type) {}",
        "usedDeclarations": [
          "stats",
          "fs = require('../fs')"
        ]
      }
    }
  },
  "node_modules\\fs-extra\\lib\\ensure\\symlink.js": {
    "filePath": "node_modules\\fs-extra\\lib\\ensure\\symlink.js",
    "fileContent": "'use strict'\n\nconst u = require('universalify').fromPromise\nconst path = require('path')\nconst fs = require('../fs')\n\nconst { mkdirs, mkdirsSync } = require('../mkdirs')\n\nconst { symlinkPaths, symlinkPathsSync } = require('./symlink-paths')\nconst { symlinkType, symlinkTypeSync } = require('./symlink-type')\n\nconst { pathExists } = require('../path-exists')\n\nconst { areIdentical } = require('../util/stat')\n\nasync function createSymlink (srcpath, dstpath, type) {\n  let stats\n  try {\n    stats = await fs.lstat(dstpath)\n  } catch { }\n\n  if (stats && stats.isSymbolicLink()) {\n    const [srcStat, dstStat] = await Promise.all([\n      fs.stat(srcpath),\n      fs.stat(dstpath)\n    ])\n\n    if (areIdentical(srcStat, dstStat)) return\n  }\n\n  const relative = await symlinkPaths(srcpath, dstpath)\n  srcpath = relative.toDst\n  const toType = await symlinkType(relative.toCwd, type)\n  const dir = path.dirname(dstpath)\n\n  if (!(await pathExists(dir))) {\n    await mkdirs(dir)\n  }\n\n  return fs.symlink(srcpath, dstpath, toType)\n}\n\nfunction createSymlinkSync (srcpath, dstpath, type) {\n  let stats\n  try {\n    stats = fs.lstatSync(dstpath)\n  } catch { }\n  if (stats && stats.isSymbolicLink()) {\n    const srcStat = fs.statSync(srcpath)\n    const dstStat = fs.statSync(dstpath)\n    if (areIdentical(srcStat, dstStat)) return\n  }\n\n  const relative = symlinkPathsSync(srcpath, dstpath)\n  srcpath = relative.toDst\n  type = symlinkTypeSync(relative.toCwd, type)\n  const dir = path.dirname(dstpath)\n  const exists = fs.existsSync(dir)\n  if (exists) return fs.symlinkSync(srcpath, dstpath, type)\n  mkdirsSync(dir)\n  return fs.symlinkSync(srcpath, dstpath, type)\n}\n\nmodule.exports = {\n  createSymlink: u(createSymlink),\n  createSymlinkSync\n}\n",
    "functions": {
      "createSymlink": {
        "params": [
          "srcpath",
          "dstpath",
          "type"
        ],
        "body": "{\n  let stats;\n  try {\n    stats = await fs.lstat(dstpath);\n  } catch {}\n  if (stats && stats.isSymbolicLink()) {\n    const [srcStat, dstStat] = await Promise.all([fs.stat(srcpath), fs.stat(dstpath)]);\n    if (areIdentical(srcStat, dstStat)) return;\n  }\n  const relative = await symlinkPaths(srcpath, dstpath);\n  srcpath = relative.toDst;\n  const toType = await symlinkType(relative.toCwd, type);\n  const dir = path.dirname(dstpath);\n  if (!await pathExists(dir)) {\n    await mkdirs(dir);\n  }\n  return fs.symlink(srcpath, dstpath, toType);\n}",
        "functionDeclaration": "function createSymlink(srcpath, dstpath, type) {}",
        "usedDeclarations": [
          "fs = require('../fs')",
          "path = require('path')"
        ]
      },
      "createSymlinkSync": {
        "params": [
          "srcpath",
          "dstpath",
          "type"
        ],
        "body": "{\n  let stats;\n  try {\n    stats = fs.lstatSync(dstpath);\n  } catch {}\n  if (stats && stats.isSymbolicLink()) {\n    const srcStat = fs.statSync(srcpath);\n    const dstStat = fs.statSync(dstpath);\n    if (areIdentical(srcStat, dstStat)) return;\n  }\n  const relative = symlinkPathsSync(srcpath, dstpath);\n  srcpath = relative.toDst;\n  type = symlinkTypeSync(relative.toCwd, type);\n  const dir = path.dirname(dstpath);\n  const exists = fs.existsSync(dir);\n  if (exists) return fs.symlinkSync(srcpath, dstpath, type);\n  mkdirsSync(dir);\n  return fs.symlinkSync(srcpath, dstpath, type);\n}",
        "functionDeclaration": "function createSymlinkSync(srcpath, dstpath, type) {}",
        "usedDeclarations": [
          "stats",
          "fs = require('../fs')",
          "relative = await symlinkPaths(srcpath, dstpath)",
          "dir = path.dirname(dstpath)",
          "path = require('path')"
        ]
      }
    }
  },
  "node_modules\\fs-extra\\lib\\fs\\index.js": {
    "filePath": "node_modules\\fs-extra\\lib\\fs\\index.js",
    "fileContent": "'use strict'\n// This is adapted from https://github.com/normalize/mz\n// Copyright (c) 2014-2016 Jonathan Ong me@jongleberry.com and Contributors\nconst u = require('universalify').fromCallback\nconst fs = require('graceful-fs')\n\nconst api = [\n  'access',\n  'appendFile',\n  'chmod',\n  'chown',\n  'close',\n  'copyFile',\n  'fchmod',\n  'fchown',\n  'fdatasync',\n  'fstat',\n  'fsync',\n  'ftruncate',\n  'futimes',\n  'lchmod',\n  'lchown',\n  'link',\n  'lstat',\n  'mkdir',\n  'mkdtemp',\n  'open',\n  'opendir',\n  'readdir',\n  'readFile',\n  'readlink',\n  'realpath',\n  'rename',\n  'rm',\n  'rmdir',\n  'stat',\n  'symlink',\n  'truncate',\n  'unlink',\n  'utimes',\n  'writeFile'\n].filter(key => {\n  // Some commands are not available on some systems. Ex:\n  // fs.cp was added in Node.js v16.7.0\n  // fs.lchown is not available on at least some Linux\n  return typeof fs[key] === 'function'\n})\n\n// Export cloned fs:\nObject.assign(exports, fs)\n\n// Universalify async methods:\napi.forEach(method => {\n  exports[method] = u(fs[method])\n})\n\n// We differ from mz/fs in that we still ship the old, broken, fs.exists()\n// since we are a drop-in replacement for the native module\nexports.exists = function (filename, callback) {\n  if (typeof callback === 'function') {\n    return fs.exists(filename, callback)\n  }\n  return new Promise(resolve => {\n    return fs.exists(filename, resolve)\n  })\n}\n\n// fs.read(), fs.write(), fs.readv(), & fs.writev() need special treatment due to multiple callback args\n\nexports.read = function (fd, buffer, offset, length, position, callback) {\n  if (typeof callback === 'function') {\n    return fs.read(fd, buffer, offset, length, position, callback)\n  }\n  return new Promise((resolve, reject) => {\n    fs.read(fd, buffer, offset, length, position, (err, bytesRead, buffer) => {\n      if (err) return reject(err)\n      resolve({ bytesRead, buffer })\n    })\n  })\n}\n\n// Function signature can be\n// fs.write(fd, buffer[, offset[, length[, position]]], callback)\n// OR\n// fs.write(fd, string[, position[, encoding]], callback)\n// We need to handle both cases, so we use ...args\nexports.write = function (fd, buffer, ...args) {\n  if (typeof args[args.length - 1] === 'function') {\n    return fs.write(fd, buffer, ...args)\n  }\n\n  return new Promise((resolve, reject) => {\n    fs.write(fd, buffer, ...args, (err, bytesWritten, buffer) => {\n      if (err) return reject(err)\n      resolve({ bytesWritten, buffer })\n    })\n  })\n}\n\n// Function signature is\n// s.readv(fd, buffers[, position], callback)\n// We need to handle the optional arg, so we use ...args\nexports.readv = function (fd, buffers, ...args) {\n  if (typeof args[args.length - 1] === 'function') {\n    return fs.readv(fd, buffers, ...args)\n  }\n\n  return new Promise((resolve, reject) => {\n    fs.readv(fd, buffers, ...args, (err, bytesRead, buffers) => {\n      if (err) return reject(err)\n      resolve({ bytesRead, buffers })\n    })\n  })\n}\n\n// Function signature is\n// s.writev(fd, buffers[, position], callback)\n// We need to handle the optional arg, so we use ...args\nexports.writev = function (fd, buffers, ...args) {\n  if (typeof args[args.length - 1] === 'function') {\n    return fs.writev(fd, buffers, ...args)\n  }\n\n  return new Promise((resolve, reject) => {\n    fs.writev(fd, buffers, ...args, (err, bytesWritten, buffers) => {\n      if (err) return reject(err)\n      resolve({ bytesWritten, buffers })\n    })\n  })\n}\n\n// fs.realpath.native sometimes not available if fs is monkey-patched\nif (typeof fs.realpath.native === 'function') {\n  exports.realpath.native = u(fs.realpath.native)\n} else {\n  process.emitWarning(\n    'fs.realpath.native is not a function. Is fs being monkey-patched?',\n    'Warning', 'fs-extra-WARN0003'\n  )\n}\n",
    "functions": {
      "(anonymous)": {
        "params": [
          "fd",
          "buffers",
          null
        ],
        "body": "{\n  if (typeof args[args.length - 1] === 'function') {\n    return fs.writev(fd, buffers, ...args);\n  }\n  return new Promise((resolve, reject) => {\n    fs.writev(fd, buffers, ...args, (err, bytesWritten, buffers) => {\n      if (err) return reject(err);\n      resolve({\n        bytesWritten,\n        buffers\n      });\n    });\n  });\n}",
        "functionDeclaration": "function (fd, buffers, ...args) {}",
        "usedDeclarations": [
          "fs = require('graceful-fs')"
        ]
      }
    }
  },
  "node_modules\\fs-extra\\lib\\index.js": {
    "filePath": "node_modules\\fs-extra\\lib\\index.js",
    "fileContent": "'use strict'\n\nmodule.exports = {\n  // Export promiseified graceful-fs:\n  ...require('./fs'),\n  // Export extra methods:\n  ...require('./copy'),\n  ...require('./empty'),\n  ...require('./ensure'),\n  ...require('./json'),\n  ...require('./mkdirs'),\n  ...require('./move'),\n  ...require('./output-file'),\n  ...require('./path-exists'),\n  ...require('./remove')\n}\n",
    "functions": {}
  },
  "node_modules\\fs-extra\\lib\\json\\index.js": {
    "filePath": "node_modules\\fs-extra\\lib\\json\\index.js",
    "fileContent": "'use strict'\n\nconst u = require('universalify').fromPromise\nconst jsonFile = require('./jsonfile')\n\njsonFile.outputJson = u(require('./output-json'))\njsonFile.outputJsonSync = require('./output-json-sync')\n// aliases\njsonFile.outputJSON = jsonFile.outputJson\njsonFile.outputJSONSync = jsonFile.outputJsonSync\njsonFile.writeJSON = jsonFile.writeJson\njsonFile.writeJSONSync = jsonFile.writeJsonSync\njsonFile.readJSON = jsonFile.readJson\njsonFile.readJSONSync = jsonFile.readJsonSync\n\nmodule.exports = jsonFile\n",
    "functions": {}
  },
  "node_modules\\fs-extra\\lib\\json\\jsonfile.js": {
    "filePath": "node_modules\\fs-extra\\lib\\json\\jsonfile.js",
    "fileContent": "'use strict'\n\nconst jsonFile = require('jsonfile')\n\nmodule.exports = {\n  // jsonfile exports\n  readJson: jsonFile.readFile,\n  readJsonSync: jsonFile.readFileSync,\n  writeJson: jsonFile.writeFile,\n  writeJsonSync: jsonFile.writeFileSync\n}\n",
    "functions": {}
  },
  "node_modules\\fs-extra\\lib\\json\\output-json-sync.js": {
    "filePath": "node_modules\\fs-extra\\lib\\json\\output-json-sync.js",
    "fileContent": "'use strict'\n\nconst { stringify } = require('jsonfile/utils')\nconst { outputFileSync } = require('../output-file')\n\nfunction outputJsonSync (file, data, options) {\n  const str = stringify(data, options)\n\n  outputFileSync(file, str, options)\n}\n\nmodule.exports = outputJsonSync\n",
    "functions": {
      "outputJsonSync": {
        "params": [
          "file",
          "data",
          "options"
        ],
        "body": "{\n  const str = stringify(data, options);\n  outputFileSync(file, str, options);\n}",
        "functionDeclaration": "function outputJsonSync(file, data, options) {}",
        "usedDeclarations": []
      }
    }
  },
  "node_modules\\fs-extra\\lib\\json\\output-json.js": {
    "filePath": "node_modules\\fs-extra\\lib\\json\\output-json.js",
    "fileContent": "'use strict'\n\nconst { stringify } = require('jsonfile/utils')\nconst { outputFile } = require('../output-file')\n\nasync function outputJson (file, data, options = {}) {\n  const str = stringify(data, options)\n\n  await outputFile(file, str, options)\n}\n\nmodule.exports = outputJson\n",
    "functions": {
      "outputJson": {
        "params": [
          "file",
          "data",
          null
        ],
        "body": "{\n  const str = stringify(data, options);\n  await outputFile(file, str, options);\n}",
        "functionDeclaration": "function outputJson(file, data, options = {}) {}",
        "usedDeclarations": []
      }
    }
  },
  "node_modules\\fs-extra\\lib\\mkdirs\\index.js": {
    "filePath": "node_modules\\fs-extra\\lib\\mkdirs\\index.js",
    "fileContent": "'use strict'\nconst u = require('universalify').fromPromise\nconst { makeDir: _makeDir, makeDirSync } = require('./make-dir')\nconst makeDir = u(_makeDir)\n\nmodule.exports = {\n  mkdirs: makeDir,\n  mkdirsSync: makeDirSync,\n  // alias\n  mkdirp: makeDir,\n  mkdirpSync: makeDirSync,\n  ensureDir: makeDir,\n  ensureDirSync: makeDirSync\n}\n",
    "functions": {}
  },
  "node_modules\\fs-extra\\lib\\mkdirs\\make-dir.js": {
    "filePath": "node_modules\\fs-extra\\lib\\mkdirs\\make-dir.js",
    "fileContent": "'use strict'\nconst fs = require('../fs')\nconst { checkPath } = require('./utils')\n\nconst getMode = options => {\n  const defaults = { mode: 0o777 }\n  if (typeof options === 'number') return options\n  return ({ ...defaults, ...options }).mode\n}\n\nmodule.exports.makeDir = async (dir, options) => {\n  checkPath(dir)\n\n  return fs.mkdir(dir, {\n    mode: getMode(options),\n    recursive: true\n  })\n}\n\nmodule.exports.makeDirSync = (dir, options) => {\n  checkPath(dir)\n\n  return fs.mkdirSync(dir, {\n    mode: getMode(options),\n    recursive: true\n  })\n}\n",
    "functions": {}
  },
  "node_modules\\fs-extra\\lib\\mkdirs\\utils.js": {
    "filePath": "node_modules\\fs-extra\\lib\\mkdirs\\utils.js",
    "fileContent": "// Adapted from https://github.com/sindresorhus/make-dir\n// Copyright (c) Sindre Sorhus <sindresorhus@gmail.com> (sindresorhus.com)\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n// The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n'use strict'\nconst path = require('path')\n\n// https://github.com/nodejs/node/issues/8987\n// https://github.com/libuv/libuv/pull/1088\nmodule.exports.checkPath = function checkPath (pth) {\n  if (process.platform === 'win32') {\n    const pathHasInvalidWinCharacters = /[<>:\"|?*]/.test(pth.replace(path.parse(pth).root, ''))\n\n    if (pathHasInvalidWinCharacters) {\n      const error = new Error(`Path contains invalid characters: ${pth}`)\n      error.code = 'EINVAL'\n      throw error\n    }\n  }\n}\n",
    "functions": {
      "checkPath": {
        "params": [
          "pth"
        ],
        "body": "{\n  if (process.platform === 'win32') {\n    const pathHasInvalidWinCharacters = (/[<>:\"|?*]/).test(pth.replace(path.parse(pth).root, ''));\n    if (pathHasInvalidWinCharacters) {\n      const error = new Error(`Path contains invalid characters: ${pth}`);\n      error.code = 'EINVAL';\n      throw error;\n    }\n  }\n}",
        "functionDeclaration": "function checkPath(pth) {}",
        "usedDeclarations": [
          "path = require('path')"
        ]
      }
    }
  },
  "node_modules\\fs-extra\\lib\\move\\index.js": {
    "filePath": "node_modules\\fs-extra\\lib\\move\\index.js",
    "fileContent": "'use strict'\n\nconst u = require('universalify').fromPromise\nmodule.exports = {\n  move: u(require('./move')),\n  moveSync: require('./move-sync')\n}\n",
    "functions": {}
  },
  "node_modules\\fs-extra\\lib\\move\\move-sync.js": {
    "filePath": "node_modules\\fs-extra\\lib\\move\\move-sync.js",
    "fileContent": "'use strict'\n\nconst fs = require('graceful-fs')\nconst path = require('path')\nconst copySync = require('../copy').copySync\nconst removeSync = require('../remove').removeSync\nconst mkdirpSync = require('../mkdirs').mkdirpSync\nconst stat = require('../util/stat')\n\nfunction moveSync (src, dest, opts) {\n  opts = opts || {}\n  const overwrite = opts.overwrite || opts.clobber || false\n\n  const { srcStat, isChangingCase = false } = stat.checkPathsSync(src, dest, 'move', opts)\n  stat.checkParentPathsSync(src, srcStat, dest, 'move')\n  if (!isParentRoot(dest)) mkdirpSync(path.dirname(dest))\n  return doRename(src, dest, overwrite, isChangingCase)\n}\n\nfunction isParentRoot (dest) {\n  const parent = path.dirname(dest)\n  const parsedPath = path.parse(parent)\n  return parsedPath.root === parent\n}\n\nfunction doRename (src, dest, overwrite, isChangingCase) {\n  if (isChangingCase) return rename(src, dest, overwrite)\n  if (overwrite) {\n    removeSync(dest)\n    return rename(src, dest, overwrite)\n  }\n  if (fs.existsSync(dest)) throw new Error('dest already exists.')\n  return rename(src, dest, overwrite)\n}\n\nfunction rename (src, dest, overwrite) {\n  try {\n    fs.renameSync(src, dest)\n  } catch (err) {\n    if (err.code !== 'EXDEV') throw err\n    return moveAcrossDevice(src, dest, overwrite)\n  }\n}\n\nfunction moveAcrossDevice (src, dest, overwrite) {\n  const opts = {\n    overwrite,\n    errorOnExist: true,\n    preserveTimestamps: true\n  }\n  copySync(src, dest, opts)\n  return removeSync(src)\n}\n\nmodule.exports = moveSync\n",
    "functions": {
      "moveSync": {
        "params": [
          "src",
          "dest",
          "opts"
        ],
        "body": "{\n  opts = opts || ({});\n  const overwrite = opts.overwrite || opts.clobber || false;\n  const {srcStat, isChangingCase = false} = stat.checkPathsSync(src, dest, 'move', opts);\n  stat.checkParentPathsSync(src, srcStat, dest, 'move');\n  if (!isParentRoot(dest)) mkdirpSync(path.dirname(dest));\n  return doRename(src, dest, overwrite, isChangingCase);\n}",
        "functionDeclaration": "function moveSync(src, dest, opts) {}",
        "usedDeclarations": [
          "stat = require('../util/stat')",
          "mkdirpSync = require('../mkdirs').mkdirpSync",
          "path = require('path')"
        ]
      },
      "isParentRoot": {
        "params": [
          "dest"
        ],
        "body": "{\n  const parent = path.dirname(dest);\n  const parsedPath = path.parse(parent);\n  return parsedPath.root === parent;\n}",
        "functionDeclaration": "function isParentRoot(dest) {}",
        "usedDeclarations": [
          "path = require('path')"
        ]
      },
      "doRename": {
        "params": [
          "src",
          "dest",
          "overwrite",
          "isChangingCase"
        ],
        "body": "{\n  if (isChangingCase) return rename(src, dest, overwrite);\n  if (overwrite) {\n    removeSync(dest);\n    return rename(src, dest, overwrite);\n  }\n  if (fs.existsSync(dest)) throw new Error('dest already exists.');\n  return rename(src, dest, overwrite);\n}",
        "functionDeclaration": "function doRename(src, dest, overwrite, isChangingCase) {}",
        "usedDeclarations": [
          "overwrite = opts.overwrite || opts.clobber || false",
          "removeSync = require('../remove').removeSync",
          "fs = require('graceful-fs')"
        ]
      },
      "rename": {
        "params": [
          "src",
          "dest",
          "overwrite"
        ],
        "body": "{\n  try {\n    fs.renameSync(src, dest);\n  } catch (err) {\n    if (err.code !== 'EXDEV') throw err;\n    return moveAcrossDevice(src, dest, overwrite);\n  }\n}",
        "functionDeclaration": "function rename(src, dest, overwrite) {}",
        "usedDeclarations": [
          "overwrite = opts.overwrite || opts.clobber || false",
          "fs = require('graceful-fs')"
        ]
      },
      "moveAcrossDevice": {
        "params": [
          "src",
          "dest",
          "overwrite"
        ],
        "body": "{\n  const opts = {\n    overwrite,\n    errorOnExist: true,\n    preserveTimestamps: true\n  };\n  copySync(src, dest, opts);\n  return removeSync(src);\n}",
        "functionDeclaration": "function moveAcrossDevice(src, dest, overwrite) {}",
        "usedDeclarations": [
          "overwrite = opts.overwrite || opts.clobber || false",
          "copySync = require('../copy').copySync",
          "removeSync = require('../remove').removeSync"
        ]
      }
    }
  },
  "node_modules\\fs-extra\\lib\\move\\move.js": {
    "filePath": "node_modules\\fs-extra\\lib\\move\\move.js",
    "fileContent": "'use strict'\n\nconst fs = require('../fs')\nconst path = require('path')\nconst { copy } = require('../copy')\nconst { remove } = require('../remove')\nconst { mkdirp } = require('../mkdirs')\nconst { pathExists } = require('../path-exists')\nconst stat = require('../util/stat')\n\nasync function move (src, dest, opts = {}) {\n  const overwrite = opts.overwrite || opts.clobber || false\n\n  const { srcStat, isChangingCase = false } = await stat.checkPaths(src, dest, 'move', opts)\n\n  await stat.checkParentPaths(src, srcStat, dest, 'move')\n\n  // If the parent of dest is not root, make sure it exists before proceeding\n  const destParent = path.dirname(dest)\n  const parsedParentPath = path.parse(destParent)\n  if (parsedParentPath.root !== destParent) {\n    await mkdirp(destParent)\n  }\n\n  return doRename(src, dest, overwrite, isChangingCase)\n}\n\nasync function doRename (src, dest, overwrite, isChangingCase) {\n  if (!isChangingCase) {\n    if (overwrite) {\n      await remove(dest)\n    } else if (await pathExists(dest)) {\n      throw new Error('dest already exists.')\n    }\n  }\n\n  try {\n    // Try w/ rename first, and try copy + remove if EXDEV\n    await fs.rename(src, dest)\n  } catch (err) {\n    if (err.code !== 'EXDEV') {\n      throw err\n    }\n    await moveAcrossDevice(src, dest, overwrite)\n  }\n}\n\nasync function moveAcrossDevice (src, dest, overwrite) {\n  const opts = {\n    overwrite,\n    errorOnExist: true,\n    preserveTimestamps: true\n  }\n\n  await copy(src, dest, opts)\n  return remove(src)\n}\n\nmodule.exports = move\n",
    "functions": {
      "move": {
        "params": [
          "src",
          "dest",
          null
        ],
        "body": "{\n  const overwrite = opts.overwrite || opts.clobber || false;\n  const {srcStat, isChangingCase = false} = await stat.checkPaths(src, dest, 'move', opts);\n  await stat.checkParentPaths(src, srcStat, dest, 'move');\n  const destParent = path.dirname(dest);\n  const parsedParentPath = path.parse(destParent);\n  if (parsedParentPath.root !== destParent) {\n    await mkdirp(destParent);\n  }\n  return doRename(src, dest, overwrite, isChangingCase);\n}",
        "functionDeclaration": "function move(src, dest, opts = {}) {}",
        "usedDeclarations": [
          "stat = require('../util/stat')",
          "path = require('path')"
        ]
      },
      "doRename": {
        "params": [
          "src",
          "dest",
          "overwrite",
          "isChangingCase"
        ],
        "body": "{\n  if (!isChangingCase) {\n    if (overwrite) {\n      await remove(dest);\n    } else if (await pathExists(dest)) {\n      throw new Error('dest already exists.');\n    }\n  }\n  try {\n    await fs.rename(src, dest);\n  } catch (err) {\n    if (err.code !== 'EXDEV') {\n      throw err;\n    }\n    await moveAcrossDevice(src, dest, overwrite);\n  }\n}",
        "functionDeclaration": "function doRename(src, dest, overwrite, isChangingCase) {}",
        "usedDeclarations": [
          "overwrite = opts.overwrite || opts.clobber || false",
          "fs = require('../fs')"
        ]
      },
      "moveAcrossDevice": {
        "params": [
          "src",
          "dest",
          "overwrite"
        ],
        "body": "{\n  const opts = {\n    overwrite,\n    errorOnExist: true,\n    preserveTimestamps: true\n  };\n  await copy(src, dest, opts);\n  return remove(src);\n}",
        "functionDeclaration": "function moveAcrossDevice(src, dest, overwrite) {}",
        "usedDeclarations": [
          "overwrite = opts.overwrite || opts.clobber || false"
        ]
      }
    }
  },
  "node_modules\\fs-extra\\lib\\output-file\\index.js": {
    "filePath": "node_modules\\fs-extra\\lib\\output-file\\index.js",
    "fileContent": "'use strict'\n\nconst u = require('universalify').fromPromise\nconst fs = require('../fs')\nconst path = require('path')\nconst mkdir = require('../mkdirs')\nconst pathExists = require('../path-exists').pathExists\n\nasync function outputFile (file, data, encoding = 'utf-8') {\n  const dir = path.dirname(file)\n\n  if (!(await pathExists(dir))) {\n    await mkdir.mkdirs(dir)\n  }\n\n  return fs.writeFile(file, data, encoding)\n}\n\nfunction outputFileSync (file, ...args) {\n  const dir = path.dirname(file)\n  if (!fs.existsSync(dir)) {\n    mkdir.mkdirsSync(dir)\n  }\n\n  fs.writeFileSync(file, ...args)\n}\n\nmodule.exports = {\n  outputFile: u(outputFile),\n  outputFileSync\n}\n",
    "functions": {
      "outputFile": {
        "params": [
          "file",
          "data",
          null
        ],
        "body": "{\n  const dir = path.dirname(file);\n  if (!await pathExists(dir)) {\n    await mkdir.mkdirs(dir);\n  }\n  return fs.writeFile(file, data, encoding);\n}",
        "functionDeclaration": "function outputFile(file, data, encoding = 'utf-8') {}",
        "usedDeclarations": [
          "path = require('path')",
          "pathExists = require('../path-exists').pathExists",
          "mkdir = require('../mkdirs')",
          "fs = require('../fs')"
        ]
      },
      "outputFileSync": {
        "params": [
          "file",
          null
        ],
        "body": "{\n  const dir = path.dirname(file);\n  if (!fs.existsSync(dir)) {\n    mkdir.mkdirsSync(dir);\n  }\n  fs.writeFileSync(file, ...args);\n}",
        "functionDeclaration": "function outputFileSync(file, ...args) {}",
        "usedDeclarations": [
          "dir = path.dirname(file)",
          "path = require('path')",
          "fs = require('../fs')",
          "mkdir = require('../mkdirs')"
        ]
      }
    }
  },
  "node_modules\\fs-extra\\lib\\path-exists\\index.js": {
    "filePath": "node_modules\\fs-extra\\lib\\path-exists\\index.js",
    "fileContent": "'use strict'\nconst u = require('universalify').fromPromise\nconst fs = require('../fs')\n\nfunction pathExists (path) {\n  return fs.access(path).then(() => true).catch(() => false)\n}\n\nmodule.exports = {\n  pathExists: u(pathExists),\n  pathExistsSync: fs.existsSync\n}\n",
    "functions": {
      "pathExists": {
        "params": [
          "path"
        ],
        "body": "{\n  return fs.access(path).then(() => true).catch(() => false);\n}",
        "functionDeclaration": "function pathExists(path) {}",
        "usedDeclarations": [
          "fs = require('../fs')"
        ]
      }
    }
  },
  "node_modules\\fs-extra\\lib\\remove\\index.js": {
    "filePath": "node_modules\\fs-extra\\lib\\remove\\index.js",
    "fileContent": "'use strict'\n\nconst fs = require('graceful-fs')\nconst u = require('universalify').fromCallback\n\nfunction remove (path, callback) {\n  fs.rm(path, { recursive: true, force: true }, callback)\n}\n\nfunction removeSync (path) {\n  fs.rmSync(path, { recursive: true, force: true })\n}\n\nmodule.exports = {\n  remove: u(remove),\n  removeSync\n}\n",
    "functions": {
      "remove": {
        "params": [
          "path",
          "callback"
        ],
        "body": "{\n  fs.rm(path, {\n    recursive: true,\n    force: true\n  }, callback);\n}",
        "functionDeclaration": "function remove(path, callback) {}",
        "usedDeclarations": [
          "fs = require('graceful-fs')"
        ]
      },
      "removeSync": {
        "params": [
          "path"
        ],
        "body": "{\n  fs.rmSync(path, {\n    recursive: true,\n    force: true\n  });\n}",
        "functionDeclaration": "function removeSync(path) {}",
        "usedDeclarations": [
          "fs = require('graceful-fs')"
        ]
      }
    }
  },
  "node_modules\\fs-extra\\lib\\util\\stat.js": {
    "filePath": "node_modules\\fs-extra\\lib\\util\\stat.js",
    "fileContent": "'use strict'\n\nconst fs = require('../fs')\nconst path = require('path')\nconst u = require('universalify').fromPromise\n\nfunction getStats (src, dest, opts) {\n  const statFunc = opts.dereference\n    ? (file) => fs.stat(file, { bigint: true })\n    : (file) => fs.lstat(file, { bigint: true })\n  return Promise.all([\n    statFunc(src),\n    statFunc(dest).catch(err => {\n      if (err.code === 'ENOENT') return null\n      throw err\n    })\n  ]).then(([srcStat, destStat]) => ({ srcStat, destStat }))\n}\n\nfunction getStatsSync (src, dest, opts) {\n  let destStat\n  const statFunc = opts.dereference\n    ? (file) => fs.statSync(file, { bigint: true })\n    : (file) => fs.lstatSync(file, { bigint: true })\n  const srcStat = statFunc(src)\n  try {\n    destStat = statFunc(dest)\n  } catch (err) {\n    if (err.code === 'ENOENT') return { srcStat, destStat: null }\n    throw err\n  }\n  return { srcStat, destStat }\n}\n\nasync function checkPaths (src, dest, funcName, opts) {\n  const { srcStat, destStat } = await getStats(src, dest, opts)\n  if (destStat) {\n    if (areIdentical(srcStat, destStat)) {\n      const srcBaseName = path.basename(src)\n      const destBaseName = path.basename(dest)\n      if (funcName === 'move' &&\n        srcBaseName !== destBaseName &&\n        srcBaseName.toLowerCase() === destBaseName.toLowerCase()) {\n        return { srcStat, destStat, isChangingCase: true }\n      }\n      throw new Error('Source and destination must not be the same.')\n    }\n    if (srcStat.isDirectory() && !destStat.isDirectory()) {\n      throw new Error(`Cannot overwrite non-directory '${dest}' with directory '${src}'.`)\n    }\n    if (!srcStat.isDirectory() && destStat.isDirectory()) {\n      throw new Error(`Cannot overwrite directory '${dest}' with non-directory '${src}'.`)\n    }\n  }\n\n  if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {\n    throw new Error(errMsg(src, dest, funcName))\n  }\n\n  return { srcStat, destStat }\n}\n\nfunction checkPathsSync (src, dest, funcName, opts) {\n  const { srcStat, destStat } = getStatsSync(src, dest, opts)\n\n  if (destStat) {\n    if (areIdentical(srcStat, destStat)) {\n      const srcBaseName = path.basename(src)\n      const destBaseName = path.basename(dest)\n      if (funcName === 'move' &&\n        srcBaseName !== destBaseName &&\n        srcBaseName.toLowerCase() === destBaseName.toLowerCase()) {\n        return { srcStat, destStat, isChangingCase: true }\n      }\n      throw new Error('Source and destination must not be the same.')\n    }\n    if (srcStat.isDirectory() && !destStat.isDirectory()) {\n      throw new Error(`Cannot overwrite non-directory '${dest}' with directory '${src}'.`)\n    }\n    if (!srcStat.isDirectory() && destStat.isDirectory()) {\n      throw new Error(`Cannot overwrite directory '${dest}' with non-directory '${src}'.`)\n    }\n  }\n\n  if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {\n    throw new Error(errMsg(src, dest, funcName))\n  }\n  return { srcStat, destStat }\n}\n\n// recursively check if dest parent is a subdirectory of src.\n// It works for all file types including symlinks since it\n// checks the src and dest inodes. It starts from the deepest\n// parent and stops once it reaches the src parent or the root path.\nasync function checkParentPaths (src, srcStat, dest, funcName) {\n  const srcParent = path.resolve(path.dirname(src))\n  const destParent = path.resolve(path.dirname(dest))\n  if (destParent === srcParent || destParent === path.parse(destParent).root) return\n\n  let destStat\n  try {\n    destStat = await fs.stat(destParent, { bigint: true })\n  } catch (err) {\n    if (err.code === 'ENOENT') return\n    throw err\n  }\n\n  if (areIdentical(srcStat, destStat)) {\n    throw new Error(errMsg(src, dest, funcName))\n  }\n\n  return checkParentPaths(src, srcStat, destParent, funcName)\n}\n\nfunction checkParentPathsSync (src, srcStat, dest, funcName) {\n  const srcParent = path.resolve(path.dirname(src))\n  const destParent = path.resolve(path.dirname(dest))\n  if (destParent === srcParent || destParent === path.parse(destParent).root) return\n  let destStat\n  try {\n    destStat = fs.statSync(destParent, { bigint: true })\n  } catch (err) {\n    if (err.code === 'ENOENT') return\n    throw err\n  }\n  if (areIdentical(srcStat, destStat)) {\n    throw new Error(errMsg(src, dest, funcName))\n  }\n  return checkParentPathsSync(src, srcStat, destParent, funcName)\n}\n\nfunction areIdentical (srcStat, destStat) {\n  return destStat.ino && destStat.dev && destStat.ino === srcStat.ino && destStat.dev === srcStat.dev\n}\n\n// return true if dest is a subdir of src, otherwise false.\n// It only checks the path strings.\nfunction isSrcSubdir (src, dest) {\n  const srcArr = path.resolve(src).split(path.sep).filter(i => i)\n  const destArr = path.resolve(dest).split(path.sep).filter(i => i)\n  return srcArr.every((cur, i) => destArr[i] === cur)\n}\n\nfunction errMsg (src, dest, funcName) {\n  return `Cannot ${funcName} '${src}' to a subdirectory of itself, '${dest}'.`\n}\n\nmodule.exports = {\n  // checkPaths\n  checkPaths: u(checkPaths),\n  checkPathsSync,\n  // checkParent\n  checkParentPaths: u(checkParentPaths),\n  checkParentPathsSync,\n  // Misc\n  isSrcSubdir,\n  areIdentical\n}\n",
    "functions": {
      "getStats": {
        "params": [
          "src",
          "dest",
          "opts"
        ],
        "body": "{\n  const statFunc = opts.dereference ? file => fs.stat(file, {\n    bigint: true\n  }) : file => fs.lstat(file, {\n    bigint: true\n  });\n  return Promise.all([statFunc(src), statFunc(dest).catch(err => {\n    if (err.code === 'ENOENT') return null;\n    throw err;\n  })]).then(([srcStat, destStat]) => ({\n    srcStat,\n    destStat\n  }));\n}",
        "functionDeclaration": "function getStats(src, dest, opts) {}",
        "usedDeclarations": [
          "fs = require('../fs')"
        ]
      },
      "getStatsSync": {
        "params": [
          "src",
          "dest",
          "opts"
        ],
        "body": "{\n  let destStat;\n  const statFunc = opts.dereference ? file => fs.statSync(file, {\n    bigint: true\n  }) : file => fs.lstatSync(file, {\n    bigint: true\n  });\n  const srcStat = statFunc(src);\n  try {\n    destStat = statFunc(dest);\n  } catch (err) {\n    if (err.code === 'ENOENT') return {\n      srcStat,\n      destStat: null\n    };\n    throw err;\n  }\n  return {\n    srcStat,\n    destStat\n  };\n}",
        "functionDeclaration": "function getStatsSync(src, dest, opts) {}",
        "usedDeclarations": [
          "statFunc = opts.dereference ? file => fs.stat(file, {\n  bigint: true\n}) : file => fs.lstat(file, {\n  bigint: true\n})",
          "fs = require('../fs')"
        ]
      },
      "checkPaths": {
        "params": [
          "src",
          "dest",
          "funcName",
          "opts"
        ],
        "body": "{\n  const {srcStat, destStat} = await getStats(src, dest, opts);\n  if (destStat) {\n    if (areIdentical(srcStat, destStat)) {\n      const srcBaseName = path.basename(src);\n      const destBaseName = path.basename(dest);\n      if (funcName === 'move' && srcBaseName !== destBaseName && srcBaseName.toLowerCase() === destBaseName.toLowerCase()) {\n        return {\n          srcStat,\n          destStat,\n          isChangingCase: true\n        };\n      }\n      throw new Error('Source and destination must not be the same.');\n    }\n    if (srcStat.isDirectory() && !destStat.isDirectory()) {\n      throw new Error(`Cannot overwrite non-directory '${dest}' with directory '${src}'.`);\n    }\n    if (!srcStat.isDirectory() && destStat.isDirectory()) {\n      throw new Error(`Cannot overwrite directory '${dest}' with non-directory '${src}'.`);\n    }\n  }\n  if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {\n    throw new Error(errMsg(src, dest, funcName));\n  }\n  return {\n    srcStat,\n    destStat\n  };\n}",
        "functionDeclaration": "function checkPaths(src, dest, funcName, opts) {}",
        "usedDeclarations": [
          "srcStat = statFunc(src)",
          "destStat",
          "path = require('path')"
        ]
      },
      "checkPathsSync": {
        "params": [
          "src",
          "dest",
          "funcName",
          "opts"
        ],
        "body": "{\n  const {srcStat, destStat} = getStatsSync(src, dest, opts);\n  if (destStat) {\n    if (areIdentical(srcStat, destStat)) {\n      const srcBaseName = path.basename(src);\n      const destBaseName = path.basename(dest);\n      if (funcName === 'move' && srcBaseName !== destBaseName && srcBaseName.toLowerCase() === destBaseName.toLowerCase()) {\n        return {\n          srcStat,\n          destStat,\n          isChangingCase: true\n        };\n      }\n      throw new Error('Source and destination must not be the same.');\n    }\n    if (srcStat.isDirectory() && !destStat.isDirectory()) {\n      throw new Error(`Cannot overwrite non-directory '${dest}' with directory '${src}'.`);\n    }\n    if (!srcStat.isDirectory() && destStat.isDirectory()) {\n      throw new Error(`Cannot overwrite directory '${dest}' with non-directory '${src}'.`);\n    }\n  }\n  if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {\n    throw new Error(errMsg(src, dest, funcName));\n  }\n  return {\n    srcStat,\n    destStat\n  };\n}",
        "functionDeclaration": "function checkPathsSync(src, dest, funcName, opts) {}",
        "usedDeclarations": [
          "srcStat = statFunc(src)",
          "destStat",
          "srcBaseName = path.basename(src)",
          "path = require('path')",
          "destBaseName = path.basename(dest)"
        ]
      },
      "checkParentPaths": {
        "params": [
          "src",
          "srcStat",
          "dest",
          "funcName"
        ],
        "body": "{\n  const srcParent = path.resolve(path.dirname(src));\n  const destParent = path.resolve(path.dirname(dest));\n  if (destParent === srcParent || destParent === path.parse(destParent).root) return;\n  let destStat;\n  try {\n    destStat = await fs.stat(destParent, {\n      bigint: true\n    });\n  } catch (err) {\n    if (err.code === 'ENOENT') return;\n    throw err;\n  }\n  if (areIdentical(srcStat, destStat)) {\n    throw new Error(errMsg(src, dest, funcName));\n  }\n  return checkParentPaths(src, srcStat, destParent, funcName);\n}",
        "functionDeclaration": "function checkParentPaths(src, srcStat, dest, funcName) {}",
        "usedDeclarations": [
          "srcStat = statFunc(src)",
          "path = require('path')",
          "destStat",
          "fs = require('../fs')"
        ]
      },
      "checkParentPathsSync": {
        "params": [
          "src",
          "srcStat",
          "dest",
          "funcName"
        ],
        "body": "{\n  const srcParent = path.resolve(path.dirname(src));\n  const destParent = path.resolve(path.dirname(dest));\n  if (destParent === srcParent || destParent === path.parse(destParent).root) return;\n  let destStat;\n  try {\n    destStat = fs.statSync(destParent, {\n      bigint: true\n    });\n  } catch (err) {\n    if (err.code === 'ENOENT') return;\n    throw err;\n  }\n  if (areIdentical(srcStat, destStat)) {\n    throw new Error(errMsg(src, dest, funcName));\n  }\n  return checkParentPathsSync(src, srcStat, destParent, funcName);\n}",
        "functionDeclaration": "function checkParentPathsSync(src, srcStat, dest, funcName) {}",
        "usedDeclarations": [
          "srcStat = statFunc(src)",
          "srcParent = path.resolve(path.dirname(src))",
          "path = require('path')",
          "destParent = path.resolve(path.dirname(dest))",
          "destStat",
          "fs = require('../fs')"
        ]
      },
      "areIdentical": {
        "params": [
          "srcStat",
          "destStat"
        ],
        "body": "{\n  return destStat.ino && destStat.dev && destStat.ino === srcStat.ino && destStat.dev === srcStat.dev;\n}",
        "functionDeclaration": "function areIdentical(srcStat, destStat) {}",
        "usedDeclarations": [
          "srcStat = statFunc(src)",
          "destStat"
        ]
      },
      "isSrcSubdir": {
        "params": [
          "src",
          "dest"
        ],
        "body": "{\n  const srcArr = path.resolve(src).split(path.sep).filter(i => i);\n  const destArr = path.resolve(dest).split(path.sep).filter(i => i);\n  return srcArr.every((cur, i) => destArr[i] === cur);\n}",
        "functionDeclaration": "function isSrcSubdir(src, dest) {}",
        "usedDeclarations": [
          "path = require('path')"
        ]
      },
      "errMsg": {
        "params": [
          "src",
          "dest",
          "funcName"
        ],
        "body": "{\n  return `Cannot ${funcName} '${src}' to a subdirectory of itself, '${dest}'.`;\n}",
        "functionDeclaration": "function errMsg(src, dest, funcName) {}",
        "usedDeclarations": []
      }
    }
  },
  "node_modules\\fs-extra\\lib\\util\\utimes.js": {
    "filePath": "node_modules\\fs-extra\\lib\\util\\utimes.js",
    "fileContent": "'use strict'\n\nconst fs = require('../fs')\nconst u = require('universalify').fromPromise\n\nasync function utimesMillis (path, atime, mtime) {\n  // if (!HAS_MILLIS_RES) return fs.utimes(path, atime, mtime, callback)\n  const fd = await fs.open(path, 'r+')\n\n  let closeErr = null\n\n  try {\n    await fs.futimes(fd, atime, mtime)\n  } finally {\n    try {\n      await fs.close(fd)\n    } catch (e) {\n      closeErr = e\n    }\n  }\n\n  if (closeErr) {\n    throw closeErr\n  }\n}\n\nfunction utimesMillisSync (path, atime, mtime) {\n  const fd = fs.openSync(path, 'r+')\n  fs.futimesSync(fd, atime, mtime)\n  return fs.closeSync(fd)\n}\n\nmodule.exports = {\n  utimesMillis: u(utimesMillis),\n  utimesMillisSync\n}\n",
    "functions": {
      "utimesMillis": {
        "params": [
          "path",
          "atime",
          "mtime"
        ],
        "body": "{\n  const fd = await fs.open(path, 'r+');\n  let closeErr = null;\n  try {\n    await fs.futimes(fd, atime, mtime);\n  } finally {\n    try {\n      await fs.close(fd);\n    } catch (e) {\n      closeErr = e;\n    }\n  }\n  if (closeErr) {\n    throw closeErr;\n  }\n}",
        "functionDeclaration": "function utimesMillis(path, atime, mtime) {}",
        "usedDeclarations": [
          "fs = require('../fs')"
        ]
      },
      "utimesMillisSync": {
        "params": [
          "path",
          "atime",
          "mtime"
        ],
        "body": "{\n  const fd = fs.openSync(path, 'r+');\n  fs.futimesSync(fd, atime, mtime);\n  return fs.closeSync(fd);\n}",
        "functionDeclaration": "function utimesMillisSync(path, atime, mtime) {}",
        "usedDeclarations": [
          "fd = await fs.open(path, 'r+')",
          "fs = require('../fs')"
        ]
      }
    }
  }
}